diff --git a/Makefile b/Makefile
index 6fc9c1c51..fc4c95332 100644
--- a/Makefile
+++ b/Makefile
@@ -104,7 +104,7 @@ ifeq ("$(TARGETOS)", "trusty")
 endif
 
 .PHONY: all clean host target \
-	manager executor ci hub \
+	manager executor kfuzztest ci hub \
 	execprog mutate prog2c trace2syz repro upgrade db \
 	usbgen symbolize cover kconf syz-build crush \
 	bin/syz-extract bin/syz-fmt \
@@ -118,7 +118,7 @@ endif
 
 all: host target
 host: manager repro mutate prog2c db upgrade
-target: execprog executor
+target: execprog executor check_syzos
 
 executor: descriptions
 ifeq ($(TARGETOS),fuchsia)
@@ -217,6 +217,9 @@ syz-build:
 bisect: descriptions
 	GOOS=$(HOSTOS) GOARCH=$(HOSTARCH) $(HOSTGO) build $(GOHOSTFLAGS) -o ./bin/syz-bisect github.com/google/syzkaller/tools/syz-bisect
 
+kfuzztest: descriptions
+	GOOS=$(HOSTOS) GOARCH=$(HOSTARCH) $(HOSTGO) build $(GOHOSTFLAGS) -o ./bin/syz-kfuzztest github.com/google/syzkaller/syz-kfuzztest
+
 verifier: descriptions
 	# TODO: switch syz-verifier to use syz-executor.
 	# GOOS=$(HOSTOS) GOARCH=$(HOSTARCH) $(HOSTGO) build $(GOHOSTFLAGS) -o ./bin/syz-verifier github.com/google/syzkaller/syz-verifier
@@ -427,6 +430,9 @@ check_links:
 check_html:
 	./tools/check-html.sh
 
+check_syzos: executor
+	./tools/check-syzos.sh 2>/dev/null
+
 # Check that the diff is empty. This is meant to be executed after generating
 # and formatting the code to make sure that everything is committed.
 check_diff:
diff --git a/docs/contributing.md b/docs/contributing.md
index 85ce77e6d..881b69260 100644
--- a/docs/contributing.md
+++ b/docs/contributing.md
@@ -138,19 +138,6 @@ To update `syz-env` container to the latest version do:
 docker pull gcr.io/syzkaller/env
 ```
 
-If you do not have access to the `gcr.io` registry, there is also a mirror in `docker.pkg.github.com` registry.
-In order to use it, you need to
-[authenticate Docker](https://docs.github.com/en/packages/using-github-packages-with-your-projects-ecosystem/configuring-docker-for-use-with-github-packages)
-with your Github account with:
-```
-docker login https://docker.pkg.github.com
-```
-and then pull the image and retag it to the name expected by `syz-env`:
-```
-docker pull docker.pkg.github.com/google/syzkaller/env
-docker tag docker.pkg.github.com/google/syzkaller/env gcr.io/syzkaller/env
-```
-
 You can also build the container from the respective `Dockerfile` by setting the `SYZ_ENV_BUILD` environment variable, i.e.:
 ```
 SYZ_ENV_BUILD=1 syz-env
diff --git a/docs/kfuzztest.md b/docs/kfuzztest.md
new file mode 100644
index 000000000..7a1cda534
--- /dev/null
+++ b/docs/kfuzztest.md
@@ -0,0 +1,149 @@
+# KFuzzTest Integration With syzkaller
+
+KFuzzTest, introduced initially in [this RFC](https://lore.kernel.org/all/20250813133812.926145-1-ethan.w.s.graham@gmail.com/)
+is a framework for exposing internal kernel functions to a userspace fuzzing
+engine like syzkaller. As the kernel docs put it:
+
+> The Kernel Fuzz Testing Framework (KFuzzTest) is a framework designed to
+> expose internal kernel functions to a userspace fuzzing engine.
+>
+> It is intended for testing stateless or low-state functions that are difficult
+> to reach from the system call interface, such as routines involved in file
+> format parsing or complex data transformations. This provides a method for
+> in-situ fuzzing of kernel code without requiring that it be built as a
+> separate userspace library or that its dependencies be stubbed out.
+
+This document introduces how syzkaller integrates with KFuzzTest.
+
+## Getting Started
+
+Firstly, ensure that the KFuzzTest patch series has been applied to your Linux
+tree.
+
+As of the 22nd of August 2025, the most up-to-date version can be found in
+[this Linux Kernel RFC](https://lore.kernel.org/all/20250813133812.926145-1-ethan.w.s.graham@gmail.com/).
+
+Once this is done, KFuzzTest targets can be defined on arbitrary kernel
+functions using the `FUZZ_TEST` macro as described in the kernel docs in
+`Documentation/dev-tools/kfuzztest.rst`.
+
+### Configuration Options
+
+Ensure that the following KConfig options are enabled for your kernel image:
+
+- `CONFIG_DEBUG_FS` (used as a communication interface by KFuzzTest).
+- `CONFIG_DEBUG_KERNEL`.
+- `CONFIG_KFUZZTEST`.
+
+It is also **highly** recommended to enable the following KConfig options for
+more effective fuzzing.
+
+- `CONFIG_KASAN` (catch memory bugs such as out-of-bounds-accesses).
+- `CONFIG_KCOV` (to enable coverage guided fuzzing).
+
+## Fuzzing KFuzzTest Targets
+
+Syzkaller implements three ways to fuzz KFuzzTest targets:
+
+1. `syz-manager` integration with static targets
+2. `syz-manager` with dynamic targets
+3. `syz-kfuzztest`: a standalone tool that runs inside a VM, discovers KFuzzTest
+    targets dynamically, and fuzzes them.
+
+### 1. `syz-manager` with static targets
+
+Configuration for this method is identical to `syz-manager`, and is designed to
+make it easy to integrate KFuzzTest fuzzing into existing continuous fuzzing
+deployments.
+
+One must first write a syzlang description for the KFuzzTest target(s) of
+interest, for example in `/sys/linux/my_kfuzztest_target.txt`. Each target
+should have the following format:
+
+```
+some_buffer {
+        buf     ptr[inout, array[int8]]
+        buflen  len[buf, int64]
+}
+
+kfuzztest_underflow_on_buffer(name ptr[in, string["test_underflow_on_buffer"]], data ptr[in, some_buffer], len bytesize[data]) (kfuzz_test)
+```
+
+Where:
+
+- The first argument should be a string pointer to the name of the fuzz target,
+  i.e,. the name of its `debugfs` input directory in the kernel.
+- The second should be a pointer to a struct of the type that the fuzz
+  target accepts as input.
+- The third should be the size in bytes of the input argument.
+- The call is annotated with attribute `kfuzz_test`.
+
+For more information on writing syzkaller descriptions attributes, consult the
+[syscall description](syscall_descriptions.md) and [syscall description syntax](syscall_descriptions_syntax.md)
+documentation files.
+
+To facilitate the tedious task of writing  `syz_kfuzztest_run` descriptions, a
+tool (`tools/kfuzztest-gen`) is provided to automatically generate these from a
+`vmlinux` binary. One can run the tool and paste the output into a syzlang file.
+
+```sh
+go run ./tools/kfuzztest-gen --vmlinux=path/to/vmlinux
+```
+
+After writing these descriptions to a file under the `/sys/linux/` directory
+(for example, `/sys/linux/my_fuzz_targets.txt`), they need to be compiled with
+`make descriptions`.
+
+Finally, the targets can be enabled in `syz-manager` config file in the
+`enable_syscalls` field, e.g.
+
+```json
+{
+    "enable_syscalls": [ "syz_kfuzztest_run$test_underflow_on_buffer" ]
+}
+```
+
+### 2. `syz-manager` with dynamic discovery
+
+This feature greatly reduces the amount of setup needed for fuzzing KFuzzTest
+targets, by discovering them all dynamically at launch.
+
+This approach is considered less stable than the previous as it involves
+generating descriptions for KFuzzTest targets without human input and then
+immediately fuzzing them. It does, however, better reflect our intentions for
+KFuzzTest: continuously fuzzing the kernel with a dynamically changing set of
+targets with little intervention from syzkaller maintainers.
+
+To enable this feature, configure the experimental `enable_kfuzztest` option in
+the manager configuration, which enables all discovered KFuzzTest targets by
+default.
+
+```json
+{
+    "enable_kfuzztest": true
+}
+```
+
+You must also enable pseudo-syscall `syz_kfuzztest_run`, like so:
+
+```json
+{
+    "enable_syscalls": [
+        "syz_kfuzztest_run"
+    ],
+}
+```
+
+**IMPORTANT:** for dynamic discovery to work, it is essential for the kernel
+image pointed to by the manager configuration is built with `CONFIG_DWARF4` or
+`CONFIG_DWARF5` enabled, as dynamic target discovery depends on these symbols
+being emitted.
+
+### 3. `syz-kfuzztest`, an in-VM standalone tool
+
+In contrast with `syz-manager`, `syz-kfuzztest` is designed to perform coverage
+guided fuzzing from within a VM directly rather than orchestrating a fleet of
+VMs. It is primarily targetted at development-time fuzzing, rather than longterm
+continuous fuzzing.
+
+For more information, consult [the `syz-kfuzztest` documentation](syz-kfuzztest.md).
diff --git a/docs/linux/external_fuzzing_usb.md b/docs/linux/external_fuzzing_usb.md
index 088bed881..97f571585 100644
--- a/docs/linux/external_fuzzing_usb.md
+++ b/docs/linux/external_fuzzing_usb.md
@@ -1,47 +1,25 @@
 External USB fuzzing for Linux kernel
 =====================================
 
-syzkaller supports fuzzing the Linux kernel USB subsystem from the external side.
-Instead of relying on external hardware (like [Facedancer](https://github.com/usb-tools/Facedancer)-based boards) or VM management software features (like QEMU [usbredir](https://www.spice-space.org/usbredir.html)), syzkaller fuzzes USB fully within a (potentially-virtualized) environment that runs the Linux kernel.
+syzkaller supports fuzzing the Linux kernel USB subsystem from the external USB device side.
+Instead of relying on physical hardware (like [Facedancer](https://github.com/usb-tools/Facedancer)-based boards) or VM management software features (like QEMU [usbredir](https://www.spice-space.org/usbredir.html)), syzkaller fuzzes USB fully within a (potentially-virtualized) environment that runs the Linux kernel.
 
 The USB fuzzing support in syzkaller is based on:
 
-1. [Raw Gadget](https://github.com/xairy/raw-gadget) — kernel module that implements a low-level interface for the Linux USB Gadget subsystem (now in the mainline kernel);
-2. [Dummy HCD/UDC](https://github.com/xairy/raw-gadget/tree/master/dummy_hcd) — kernel module that sets up virtual USB Device and Host controllers that are connected to each other inside the kernel (existed in the mainline kernel for a long time);
+1. [Raw Gadget](https://github.com/xairy/raw-gadget) — a kernel module that implements a low-level interface for the Linux USB Gadget subsystem (now in the mainline kernel);
+2. [Dummy HCD/UDC](https://github.com/xairy/raw-gadget/tree/master/dummy_hcd) — a kernel module that sets up virtual USB Device and Host controllers that are connected to each other inside the kernel (existed in the mainline kernel for a long time);
 3. KCOV changes that allow collecting coverage [from background kernel threads and interrupts](https://docs.kernel.org/dev-tools/kcov.html#remote-coverage-collection) (now in the mainline kernel);
 4. syzkaller changes built on top of the other parts; see the [Internals](/docs/linux/external_fuzzing_usb.md#Internals) section.
 
 Besides this documentation page, for details, see:
 
-- [Coverage-Guided USB Fuzzing with Syzkaller](https://docs.google.com/presentation/d/1z-giB9kom17Lk21YEjmceiNUVYeI6yIaG5_gZ3vKC-M/edit?usp=sharing) talk ([video](https://www.youtube.com/watch?v=1MD5JV6LfxA)) from OffensiveCon 2019 (the talk was given while the USB fuzzing support was a work-in-progress, so some details are outdated);
+- [Coverage-Guided USB Fuzzing with Syzkaller](https://docs.google.com/presentation/d/1z-giB9kom17Lk21YEjmceiNUVYeI6yIaG5_gZ3vKC-M/edit?usp=sharing) talk ([video](https://www.youtube.com/watch?v=1MD5JV6LfxA)) from OffensiveCon 2019 (was given while the USB fuzzing support was a work-in-progress, so some details are outdated);
 
-- [Fuzzing USB with Raw Gadget](https://docs.google.com/presentation/d/1sArf2cN5tAOaovlaL3KBPNDjYOk8P6tRrzfkclsbO_c/edit?usp=sharing) talk ([video](https://www.youtube.com/watch?v=AT3PQjKxa_c)) from BSides Munich 2022 (more up-to-date, but less in-depth).
+- [Fuzzing USB with Raw Gadget](https://docs.google.com/presentation/d/1sArf2cN5tAOaovlaL3KBPNDjYOk8P6tRrzfkclsbO_c/edit?usp=sharing) talk ([video](https://www.youtube.com/watch?v=AT3PQjKxa_c)) from BSides Munich 2022 (more up-to-date, but less in-depth);
 
-See [this page](/docs/linux/found_bugs_usb.md) for the list of bugs found in the Linux kernel USB stack so far.
-
-
-## Internals
-
-syzkaller defines 6 pseudo-syscalls for emulating USB devices for fuzzing (see the [syzlang descriptions](/sys/linux/vusb.txt) and the [C](/executor/common_usb.h) [implementations](/executor/common_usb_linux.h)):
-
-1. `syz_usb_connect` — handles the enumeration process of a new USB device (in simple terms: connects a new USB device; in detail: handles all requests to the control endpoint until a `SET_CONFIGURATION` request is received);
-2. `syz_usb_connect_ath9k` — flavor of `syz_usb_connect` for connecting an `ath9k` USB device.
-Not implemented as a `$`variant of `syz_usb_connect`, as `ath9k` expects a compatible device to immediately handle the firmware download requests after the enumeration (after the `SET_CONFIGURATION` request);
-3. `syz_usb_disconnect` — disconnects a USB device;
-4. `syz_usb_control_io` — handles a post-enumeration control request (`IN` or `OUT`);
-5. `syz_usb_ep_write` — handles a non-control `IN` request on an endpoint;
-6. `syz_usb_ep_read` — handles a non-control `OUT` request on an endpoint.
-
-The syzlang descriptions for these pseudo-syscalls are targeted at a few different layers:
-
-1. The common USB enumeration code is targeted by the generic `syz_usb_connect` variant.
-In addition, this generic variant also briefly touches the enumeration code in various USB drivers: the USB device descriptor fields get [patched](/sys/linux/init_vusb.go) during the program generation;
+- [External fuzzing of Linux kernel USB drivers with syzkaller](https://docs.google.com/presentation/d/1ba7Au3Gt6dEQAsfZmjUdzjVWHKxE_EdaJGU9WOSF-Ts/edit?usp=sharing) talk (outlines steps for adding new basic USB descriptions).
 
-2. The code of the class-specific drivers is targeted by `syz_usb_connect$hid`, `syz_usb_connect$cdc_ecm`, and other variants (accompanied by matching `syz_usb_control_io$*` and `syz_usb_ep_read/write$*` pseudo-syscalls).
-The descriptor fields for these `syz_usb_connect` variants are also intended to be patched during the program generation based on the driver class (to exercise various driver quirks), but so far, this has only been implemented for the HID class;
-
-3. The code of the device-specific drivers is intended to be targeted by more `syz_usb_connect` variants whose descriptors do not get patched and are fully defined in syzlang instead.
-So far, the only such (partial) descriptions have been added for the `ath9k` driver (`syz_usb_connect_ath9k` and `syz_usb_ep_write$ath9k_ep*`).
+See [this page](/docs/linux/found_bugs_usb.md) for the list of bugs found in the Linux kernel USB stack so far.
 
 
 ## Setting up
@@ -55,17 +33,17 @@ So far, the only such (partial) descriptions have been added for the `ath9k` dri
     Optionally, also enable the config options for the specific USB drivers that you wish to fuzz.
 
     As an alternative, you can use the [config](/dashboard/config/linux/upstream-usb.config) from the syzbot USB fuzzing instance.
-    This config has the options for many USB drivers commonly-used in distro kernels enabled;
+    This config has many USB drivers commonly-used in distro kernels enabled;
 
 3. Build the kernel;
 
-4. Optionally, update syzkaller descriptions by [extracting the USB IDs](/docs/linux/external_fuzzing_usb.md#updating-syzkaller-usb-ids).
+4. Optionally, update syzkaller descriptions by [extracting the USB IDs](#updating-usb-ids).
 
     This step is recommended if you wish to just rely on the existing syzlang descriptions to fuzz all USB drivers enabled in your kernel config.
 
     If you plan to add new syzlang descriptions that target a specific USB driver, this step can be skipped;
 
-5. Optionally, write syzlang descriptions for the USB driver you wish to fuzz;
+5. Optionally, [write](#internals) [syzlang](#dealing-with-complicated-descriptors) [descriptions](#handling-post-enumeration-control-requests) for the USB driver you wish to fuzz;
 
 6. Enable `syz_usb_connect`, `syz_usb_disconnect`, `syz_usb_control_io`, `syz_usb_ep_write` and `syz_usb_ep_read` pseudo-syscalls (or any of their specific variants) in the manager config;
 
@@ -80,30 +58,108 @@ So far, the only such (partial) descriptions have been added for the `ath9k` dri
     You should also see a decent amount of coverage in `drivers/usb/core/*` after the first few programs get added to the corpus.
 
 
-## Limitations
+## Internals
 
-Most of the limitations of the USB fuzzing support in syzkaller stem from the features [missing](https://github.com/xairy/raw-gadget/tree/master?tab=readme-ov-file#limitations) from the Raw Gadget and Dummy HCD/UDC implementations (USB 3, isochronous transfers, etc).
+syzkaller defines 5 main pseudo-syscalls for fuzzing USB drivers (see the [syzlang descriptions](/sys/linux/vusb.txt) and the [C](/executor/common_usb.h) [implementations](/executor/common_usb_linux.h)):
 
-In addition, `syz_usb_connect` only supports devices with a single configuration (but this can be fixed).
-This is not a critical limitation, as most kernel drivers are tied to specific interfaces and do not care about the configurations.
-However, there are USB devices whose drivers assume the device to have multiple specific configurations.
+1. `syz_usb_connect` — handles the enumeration process of a new USB device (in simple terms: connects a new USB device; in detail: handles all control requests up until a `SET_CONFIGURATION` request is received);
+2. `syz_usb_disconnect` — disconnects a USB device;
+3. `syz_usb_control_io` — handles a post-enumeration control request (`IN` or `OUT`);
+4. `syz_usb_ep_write` — handles a non-control `IN` request on an endpoint;
+5. `syz_usb_ep_read` — handles a non-control `OUT` request on an endpoint.
+
+Additionally, there is the `syz_usb_connect_ath9k` pseudo-syscall targeted to handle a few [post-enumeration control requests](#handling-post-enumeration-control-requests) the `ath9k` driver expects.
+
+The syzlang descriptions for these pseudo-syscalls are targeted at a few different parts of the USB subsystem:
+
+1. The common USB enumeration code is targeted by the generic `syz_usb_connect` variant.
+
+    In addition, this generic variant also briefly touches the enumeration code in various USB drivers: the USB device descriptor fields get [patched](#usb-ids-patching) during the program generation;
+
+2. The code of the class-specific drivers is targeted by `syz_usb_connect$hid`, `syz_usb_connect$cdc_ecm`, and other variants (accompanied by matching `syz_usb_control_io$*` and `syz_usb_ep_read/write$*` pseudo-syscalls).
+
+    The descriptor fields for these `syz_usb_connect` variants are also intended to be [patched](#usb-ids-patching) during the program generation based on the matching rules specific to the driver class (to exercise various driver quirks).
+So far, this has only been implemented for the HID ([see](/sys/linux/init_vusb.go) `generateUsbHidDeviceDescriptor`) and the printer ([see](/sys/linux/init_vusb.go) `generateUsbPrinterDeviceDescriptor`) classes;
+
+3. The code of the device-specific drivers is intended to be targeted by more `syz_usb_connect` variants whose descriptors do not get patched and are fully defined in syzlang instead. (However, they can be patched as well for drivers that define quirks.)
+
+    So far, the only such (partial) descriptions have been added for the `ath9k`, `rtl8150`, `sierra_net`, and `lan78xx`  drivers.
+
+
+## Dealing with complicated descriptors
+
+Many USB drivers expect a fixed USB descriptors structure from the connected USB device.
+Writing syzlang descriptions for these drivers is straightforward: just describe the required structures in syzlang.
+
+However, some drivers allow various permutations of the interface/endpoint descriptors (typically the case for class-specific drivers like UVC).
+
+Describing a fixed descriptor structure for such drivers in syzlang would allow passing the driver descriptor checks and efficiently fuzz the post-enumeration communication.
+But it would also prevent syzkaller from exploring the various error-checking paths within the driver's enumeration code.
+On the other hand, defining a relaxed structure for the descriptors would make syzkaller often fail the driver's enumeration and thus would not allow efficiently fuzzing the post-enumeration communication.
+
+There are two proposed ways to handle such drivers:
+
+1. Writing relaxed descriptions and adding seed programs (aka runtests).
+
+    This works by only defining a single `syz_usb_connect` variant with the relaxed descriptions of the USB descriptors but also adding a [seed program](#seed-programs) (into `sys/linux/test/`) that contains the `syz_usb_connect` pseudo-syscall with the specific fixed values to pass the driver's enumeration checks;
 
+2. Adding two `syz_usb_connect` variants.
 
-## Runtests
+    One with relaxed descriptions to explore the error-checking paths; and the other with fixed descriptions to allow fuzzing the post-enumeration communication.
 
-There are a few [runtests](/sys/linux/test/) for the USB pseudo-syscalls.
-They are named starting with the `vusb` prefix and can be run as:
 
-``` bash
-./bin/syz-manager -config usb-manager.cfg -mode run-tests -tests vusb
-```
+## Handling post-enumeration control requests
 
+Many USB drivers finish their enumeration procedure with the `SET_CONFIGURATION` request.
+Following this, these drivers start functioning normally and are ready to accept both control and non-control requests.
 
-## Updating syzkaller USB IDs
+However, some USB drivers expect certain control requests to be handled by the device directly following the `SET_CONFIGURATION` request.
+Without these requests being handled, these drivers abort their execution and disconnect the device.
 
-syzkaller uses a list of hardcoded [USB IDs](/sys/linux/init_vusb_ids.go) that are [patched](/sys/linux/init_vusb.go) into `syz_usb_connect` (for the generic and the HID variants) during the program generation.
+There are two proposed ways to handle such drivers:
 
-To update the syzkaller USB IDs to match the USB drivers enabled in your kernel config:
+1. Adding seed programs (aka runtests).
+
+    This works by adding a [seed program](#seed-programs) (into `sys/linux/test/`) that contains both the `syz_usb_connect` pseudo-syscall for the specific driver and a few `syz_usb_control_io` pseudo-sycalls that handle the required control requests.
+
+    This is the currently recommended way of handling such drivers, as it allows syzkaller to permute the expected post-`SET_CONFIGURATION` control requests and thus possibly trigger unexpected driver behavior during their handling.
+
+    See [#6283](https://github.com/google/syzkaller/pull/6283) for a reference implementation of this approach;
+
+2. Modifying the behavior of the `syz_usb_connect` pseudo-syscall.
+
+    An alternative approach is to modify the C implementation of the `syz_usb_connect` pseudo-syscall (or add a similar new pseudo-syscall) to handle the required post-`SET_CONFIGURATION` requests directly from C.
+
+    Right now, this approach is only implemented for the `ath9k` driver via `syz_usb_connect_ath9k`.
+Unlike `syz_usb_connect`, `syz_usb_connect_ath9k` also handles the post-`SET_CONFIGURATION` firmware download requests expected by `ath9k`.
+
+    If this approach is to be used for other drivers, the proper implementation should rework and extend `syz_usb_connect_ath9k` instead of adding more similar pseudo-syscalls.
+For example, add a new argument to `syz_usb_connect` that allows specifiying (in syzlang) the responses to post-`SET_CONFIGURATION` control requests and which one them is the last one (i.e., the condition for exiting the pseudo-syscall).
+And then port the hardcoded responses from the C implementation of `syz_usb_connect_ath9k` into syzlang and extend the functionality based on the specific new encountered cases.
+
+Note: There is also a way to describe unusual pre-`SET_CONFIGURATION` `GET_DESCRIPTOR` requests via the `conn_descs` argument of `syz_usb_connect`, but none of the class/driver-specific descriptions use this feature at the moment.
+However, this approach does not allow specifying the order of the responses if there are multiple requests of the same type and also does not allow handling pre-`SET_CONFIGURATION` non-`GET_DESCRIPTOR` requests, as no described drivers required this so far.
+
+
+## USB IDs patching
+
+Many USB drivers implement various quirks depending of which device is connected.
+Such quirks are either defined in the mathing rule table for the driver (a table of `usb_device_id` structures; [see](https://elixir.bootlin.com/linux/v6.16/source/sound/usb/card.c#L1263) e.g. `usb_audio_ids`) or hardcoded in the drivers code (by manually checking e.g. the Vendor and Product IDs against certain values; [see](https://elixir.bootlin.com/linux/v6.16/source/drivers/usb/class/usblp.c#L213) e.g. `quirk_printers`).
+
+To exercise these driver quirks, syzkaller has to provide certain values (aka IDs) within the USB descriptors for the emulated device.
+Listing these USB IDs manually in syzlang descriptions is inefficient (there are too many), so syzkaller employs the way of automatically [extracting the IDs](#updating-usb-ids) before building and then [patching them in](/sys/linux/init_vusb.go) during the program generation.
+
+The IDs defined in the driver matching rules can be extracted (and patched in) automatically; see [Updating USB IDs](#updating-usb-ids).
+
+However, the hardcoded IDs need to be specified manually (extacting them automatically is hard, as they are often embedded into the drivers code in non-standard ways).
+The proposed approach is to read the driver code to find out the hardcoded IDs and then modify the program generation code to embed them into the appropriate USB decriptors ([see](/sys/linux/init_vusb.go) e.g. `generateUsbPrinterDeviceDescriptor`).
+
+
+## Updating USB IDs
+
+syzkaller relies on a list of automatically-extracted [USB IDs](/sys/linux/init_vusb_ids.go) that are [patched](/sys/linux/init_vusb.go) into `syz_usb_connect` (for the generic, the HID, and the printer variants) during the program generation.
+
+To update the syzkaller USB IDs based on the USB drivers enabled in your kernel config:
 
 1. Apply [this](/tools/syz-usbgen/usb_ids.patch) kernel patch;
 
@@ -113,7 +169,7 @@ To update the syzkaller USB IDs to match the USB drivers enabled in your kernel
 
     Assuming you have `CONFIG_USB_RAW_GADGET=y` enabled, you can just run the [keyboard emulation program](https://raw.githubusercontent.com/xairy/raw-gadget/master/examples/keyboard.c);
 
-4. Use [syz-usbgen](/tools/syz-usbgen/usbgen.go) script to update [sys/linux/init_vusb_ids.go](/sys/linux/init_vusb_ids.go):
+4. Use [syz-usbgen](/tools/syz-usbgen/usbgen.go) to update [sys/linux/init_vusb_ids.go](/sys/linux/init_vusb_ids.go):
 
     ``` bash
     ./bin/syz-usbgen $KERNEL_LOG ./sys/linux/init_vusb_ids.go
@@ -122,6 +178,29 @@ To update the syzkaller USB IDs to match the USB drivers enabled in your kernel
 5. Revert the applied kernel patch and rebuild the kernel before starting syzkaller.
 
 
+## Seed programs
+
+There are a few [seed programs](/sys/linux/test/) (aka runtests) for the USB pseudo-syscalls (named starting with the `vusb` prefix).
+
+These seed programs serve two purposes:
+
+1. Allow syzkaller to [go](#dealing-with-complicated-descriptors) [deeper](#handling-post-enumeration-control-requests) into the driver code without having to write detailed syzlang descriptions;
+
+2. Allow veryfing the USB fuzzing functionality and catching potential descriptions breaking changes by running the seed programs as runtests:
+
+    ``` bash
+    ./bin/syz-manager -config usb-manager.cfg -mode run-tests -tests vusb
+    ```
+
+## Limitations
+
+Most of the limitations of the USB fuzzing support in syzkaller stem from the features [missing](https://github.com/xairy/raw-gadget/tree/master?tab=readme-ov-file#limitations) from the Raw Gadget and Dummy HCD/UDC implementations (USB 3, isochronous transfers, etc).
+
+In addition, `syz_usb_connect` only supports devices with a single configuration (but this can be fixed).
+This is not a critical limitation, as most kernel drivers are tied to specific interfaces and do not care about the configurations.
+However, there are USB devices whose drivers assume the device to have multiple specific configurations.
+
+
 ## Things to improve
 
 The core support for USB fuzzing is in place, but there's still space for improvement:
diff --git a/docs/syscall_descriptions_syntax.md b/docs/syscall_descriptions_syntax.md
index 33dcd3cc6..366903d2c 100644
--- a/docs/syscall_descriptions_syntax.md
+++ b/docs/syscall_descriptions_syntax.md
@@ -103,9 +103,13 @@ Call attributes are:
 "breaks_returns": ignore return values of all subsequent calls in the program in fallback feedback (can't be trusted).
 "no_generate": do not try to generate this syscall, i.e. use only seed descriptions to produce it.
 "no_minimize": do not modify instances of this syscall when trying to minimize a crashing program.
+"no_squash": do not attempt to pass squashed arguments to this syscall.
+	Without that, the fuzzer will sometimes attempt to replace complex structures with arrays of bytes,
+	possibly triggering interesting mutations, but also making programs hard to reason about.
 "fsck": the content of the compressed buffer argument for this syscall is a file system and the
     string argument is a fsck-like command that will be called to verify the filesystem
 "remote_cover": wait longer to collect remote coverage for this call.
+"kfuzz_test": the call is a kfuzztest target
 ```
 
 ## Ints
diff --git a/docs/syz-kfuzztest.md b/docs/syz-kfuzztest.md
new file mode 100644
index 000000000..4df0248c5
--- /dev/null
+++ b/docs/syz-kfuzztest.md
@@ -0,0 +1,106 @@
+# `syz-kfuzztest`
+
+`syz-kfuzztest` is a standalone tool for fuzzing KFuzzTest targets from within
+the kernel being fuzzed (e.g., a VM).
+
+It is intended to be used for development-time fuzzing rather than continuous
+fuzzing like `syz-manager`.
+
+For more information on KFuzzTest, consult the [dedicated readme](kfuzztest.md)
+or the Kernel documentation.
+
+## Usage (in-VM fuzzing)
+
+### Getting the Kernel Ready
+
+It is important that the target Kernel image has the correct KConfig options
+enabled. Namely
+
+- `CONFIG_KFUZZTEST`
+- `CONFIG_DEBUG_FS`
+- `CONFIG_DEBUG_KERNEL`
+- `CONFIG_KCOV`
+- `CONFIG_DWARF4` or `CONFIG_DWARF5`
+- `CONFIG_KASAN` _(optional, choose your favorite sanitizers for a better shot
+  at finding bugs!)_
+
+Furthermore, as you will need to connect to the VM being tested through SSH and
+launch `syz-kfuzztest` _(a Go binary with LIBC dependencies)_, it is recommended
+to create an image for the kernel being fuzzed (e.g., a Debian Bullseye image).
+Detailed instructions on how to do this can be found in
+[this setup guide](linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md).
+
+### Building and Launching the Binary
+
+The `syz-kfuzztest` binary is built with `make syz-kfuzztest`, and is intended
+to run on the Kernel fuzzed. The common case for this is within a VM _(after
+all, the tool is trying to make the Kernel crash)_.
+
+Then, ensure that the `syz-kfuzztest` binary and `vmlinux` image are copied
+over into the VM. E.g.,
+
+```sh
+scp $KERNEL/vmlinux root@my-vm:~/syz-kfuzztest/vmlinux
+scp $SYZKALLER/bin/syz-kfuzztest root@lmy-vm:~/syz-kfuzztest/syz-kfuzztest
+```
+
+Then launched like this:
+
+```
+usage: ./bin/syz-kfuzztest [flags] [enabled targets]
+
+Args:
+  One fuzz test name per enabled fuzz test arg. If empty, defaults to
+  all discovered targets.
+Example:
+  ./syz-kfuzztest -vmlinux ~/kernel/vmlinux fuzz_target_0 fuzz_target_1
+Flags:
+  -display int
+        Number of seconds between console outputs (default 5)
+  -threads int
+        Number of threads (default 2)
+  -timeout int
+        Timeout between program executions in seconds (default 0)
+  -vmlinux string
+        Path to vmlinux binary (default "vmlinux")
+  -vv int
+        verbosity
+```
+
+The enabled targets, which are listed after the flag arguments, are the names of
+the enabled fuzz targets. For example given some KFuzzTest targets:
+
+```c
+FUZZ_TEST(kfuzztest_target_1, struct input_arg_type)
+{
+    /* ... */
+}
+
+FUZZ_TEST(kfuzztest_target_2, struct input_arg_type)
+{
+    /* ... */
+}
+
+```
+
+Can be fuzzed with:
+
+```bash
+./syz-kfuzztest -vmlinux path/to/vmlinux -threads 4 kfuzztest_target_1 kfuzztest_target_2
+```
+
+If the enabled targets list is left empty, `syz-kfuzztest` will fuzz all
+discovered targets in the kernel.
+
+On exit, `syz-kfuzztest` will write the collected program counters (which are
+collected with KCOV) into a file called `pcs.out`. These program counters can
+be fed into [`syz-cover`](../tools/syz-cover/syz-cover.go) to generate an HTML
+visualization of the lines that were covered during fuzzing. It is recommended
+to do this on the host machine rather than the VM.
+
+For example:
+
+```sh
+scp root@my-vm:~/syz-kfuzztest/pcs.out .
+go run tools/syz-cover -config my.cfg pcs.out # May require the -force flag.
+```
diff --git a/executor/common_kvm.h b/executor/common_kvm.h
new file mode 100644
index 000000000..fecd00922
--- /dev/null
+++ b/executor/common_kvm.h
@@ -0,0 +1,25 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+// This file is shared between executor and csource package.
+
+// Common KVM-related definitions.
+
+#if SYZ_EXECUTOR || __NR_syz_kvm_assert_syzos_kvm_exit
+static long syz_kvm_assert_syzos_kvm_exit(volatile long a0, volatile long a1)
+{
+	struct kvm_run* run = (struct kvm_run*)a0;
+	uint64 expect = a1;
+
+	if (!run) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (run->exit_reason != expect) {
+		errno = EDOM;
+		return -1;
+	}
+	return 0;
+}
+#endif
diff --git a/executor/common_kvm_386.h b/executor/common_kvm_386.h
index 77ca4ce0e..f1b634150 100644
--- a/executor/common_kvm_386.h
+++ b/executor/common_kvm_386.h
@@ -24,6 +24,13 @@ static long syz_kvm_assert_syzos_uexit(volatile long a0, volatile long a1)
 }
 #endif
 
+#if SYZ_EXECUTOR || __NR_syz_kvm_assert_syzos_uexit
+static long syz_kvm_assert_syzos_kvm_exit(volatile long a0, volatile long a1)
+{
+	return 0;
+}
+#endif
+
 #if SYZ_EXECUTOR || __NR_syz_kvm_setup_cpu
 static volatile long syz_kvm_setup_cpu(volatile long a0, volatile long a1, volatile long a2, volatile long a3, volatile long a4, volatile long a5, volatile long a6, volatile long a7)
 {
diff --git a/executor/common_kvm_amd64.h b/executor/common_kvm_amd64.h
index c21b8a09f..1344e635f 100644
--- a/executor/common_kvm_amd64.h
+++ b/executor/common_kvm_amd64.h
@@ -7,6 +7,7 @@
 // See Intel Software Developer’s Manual Volume 3: System Programming Guide
 // for details on what happens here.
 
+#include "common_kvm.h"
 #include "common_kvm_amd64_syzos.h"
 #include "kvm.h"
 #include "kvm_amd64.S.h"
diff --git a/executor/common_kvm_amd64_syzos.h b/executor/common_kvm_amd64_syzos.h
index 828cdebff..b9c3e8315 100644
--- a/executor/common_kvm_amd64_syzos.h
+++ b/executor/common_kvm_amd64_syzos.h
@@ -3,21 +3,11 @@
 
 // This file provides guest code running inside the AMD64 KVM.
 
+#include "common_kvm_syzos.h"
 #include "kvm.h"
 #include <linux/kvm.h>
 #include <stdbool.h>
 
-// Host will map the code in this section into the guest address space.
-#define GUEST_CODE __attribute__((section("guest")))
-
-// Prevent function inlining. This attribute is applied to every guest_handle_* function,
-// making sure they remain small so that the compiler does not attempt to be too clever
-// (e.g. generate switch tables).
-#define noinline __attribute__((noinline))
-
-// Start/end of the guest section.
-extern char *__start_guest, *__stop_guest;
-
 // Compilers will eagerly try to transform the switch statement in guest_main()
 // into a jump table, unless the cases are sparse enough.
 // We use prime numbers multiplied by 10 to prevent this behavior.
@@ -29,6 +19,9 @@ typedef enum {
 	SYZOS_API_WRMSR = 30,
 	SYZOS_API_RDMSR = 50,
 	SYZOS_API_WR_CRN = 70,
+	SYZOS_API_WR_DRN = 110,
+	SYZOS_API_IN_DX = 130,
+	SYZOS_API_OUT_DX = 170,
 	SYZOS_API_STOP, // Must be the last one
 } syzos_api_id;
 
@@ -63,12 +56,20 @@ struct api_call_2 {
 	uint64 args[2];
 };
 
+struct api_call_3 {
+	struct api_call_header header;
+	uint64 args[3];
+};
+
 static void guest_uexit(uint64 exit_code);
 static void guest_execute_code(uint8* insns, uint64 size);
 static void guest_handle_cpuid(uint32 eax, uint32 ecx);
 static void guest_handle_wrmsr(uint64 reg, uint64 val);
 static void guest_handle_rdmsr(uint64 reg);
 static void guest_handle_wr_crn(struct api_call_2* cmd);
+static void guest_handle_wr_drn(struct api_call_2* cmd);
+static void guest_handle_in_dx(struct api_call_2* cmd);
+static void guest_handle_out_dx(struct api_call_3* cmd);
 
 typedef enum {
 	UEXIT_END = (uint64)-1,
@@ -120,6 +121,18 @@ guest_main(uint64 size, uint64 cpu)
 			guest_handle_wr_crn((struct api_call_2*)cmd);
 			break;
 		}
+		case SYZOS_API_WR_DRN: {
+			guest_handle_wr_drn((struct api_call_2*)cmd);
+			break;
+		}
+		case SYZOS_API_IN_DX: {
+			guest_handle_in_dx((struct api_call_2*)cmd);
+			break;
+		}
+		case SYZOS_API_OUT_DX: {
+			guest_handle_out_dx((struct api_call_3*)cmd);
+			break;
+		}
 		}
 		addr += cmd->size;
 		size -= cmd->size;
@@ -185,29 +198,120 @@ GUEST_CODE static noinline void guest_handle_rdmsr(uint64 reg)
 GUEST_CODE static noinline void guest_handle_wr_crn(struct api_call_2* cmd)
 {
 	uint64 value = cmd->args[1];
-	switch (cmd->args[0]) {
-	case 0:
+	// Prevent the compiler from generating a switch table.
+	volatile uint64 reg = cmd->args[0];
+	if (reg == 0) {
 		// Move value to CR0.
 		asm volatile("movq %0, %%cr0" ::"r"(value) : "memory");
-		break;
-	case 2:
+		return;
+	}
+	if (reg == 2) {
 		// Move value to CR2.
 		asm volatile("movq %0, %%cr2" ::"r"(value) : "memory");
-		break;
-	case 3:
+		return;
+	}
+	if (reg == 3) {
 		// Move value to CR3.
 		asm volatile("movq %0, %%cr3" ::"r"(value) : "memory");
-		break;
-	case 4:
+		return;
+	}
+	if (reg == 4) {
 		// Move value to CR4.
 		asm volatile("movq %0, %%cr4" ::"r"(value) : "memory");
-		break;
-	case 8:
+		return;
+	}
+	if (reg == 8) {
 		// Move value to CR8 (TPR - Task Priority Register).
 		asm volatile("movq %0, %%cr8" ::"r"(value) : "memory");
-		break;
-	default:
-		// Do nothing.
-		break;
+		return;
+	}
+}
+
+// Write to DRn debug register.
+GUEST_CODE static noinline void guest_handle_wr_drn(struct api_call_2* cmd)
+{
+	uint64 value = cmd->args[1];
+	volatile uint64 reg = cmd->args[0];
+	if (reg == 0) {
+		asm volatile("movq %0, %%dr0" ::"r"(value) : "memory");
+		return;
+	}
+	if (reg == 1) {
+		asm volatile("movq %0, %%dr1" ::"r"(value) : "memory");
+		return;
+	}
+	if (reg == 2) {
+		asm volatile("movq %0, %%dr2" ::"r"(value) : "memory");
+		return;
+	}
+	if (reg == 3) {
+		asm volatile("movq %0, %%dr3" ::"r"(value) : "memory");
+		return;
+	}
+	if (reg == 4) {
+		asm volatile("movq %0, %%dr4" ::"r"(value) : "memory");
+		return;
+	}
+	if (reg == 5) {
+		asm volatile("movq %0, %%dr5" ::"r"(value) : "memory");
+		return;
+	}
+	if (reg == 6) {
+		asm volatile("movq %0, %%dr6" ::"r"(value) : "memory");
+		return;
+	}
+	if (reg == 7) {
+		asm volatile("movq %0, %%dr7" ::"r"(value) : "memory");
+		return;
+	}
+}
+
+// Read data from an I/O port, should result in KVM_EXIT_IO.
+GUEST_CODE static noinline void guest_handle_in_dx(struct api_call_2* cmd)
+{
+	uint16 port = cmd->args[0];
+	volatile int size = cmd->args[1];
+
+	if (size == 1) {
+		uint8 unused;
+		// Reads 1 byte from the port in DX into AL.
+		asm volatile("inb %1, %0" : "=a"(unused) : "d"(port));
+		return;
+	}
+	if (size == 2) {
+		uint16 unused;
+		// Reads 2 bytes from the port in DX into AX.
+		asm volatile("inw %1, %0" : "=a"(unused) : "d"(port));
+		return;
+	}
+	if (size == 4) {
+		uint32 unused;
+		// Reads 4 bytes from the port in DX into EAX.
+		asm volatile("inl %1, %0" : "=a"(unused) : "d"(port));
+	}
+	return;
+}
+
+// Write data to an I/O port, should result in KVM_EXIT_IO.
+GUEST_CODE static noinline void guest_handle_out_dx(struct api_call_3* cmd)
+{
+	uint16 port = cmd->args[0];
+	volatile int size = cmd->args[1];
+	uint32 data = (uint32)cmd->args[2];
+
+	if (size == 1) {
+		// Writes 1 byte from AL to the port in DX.
+		asm volatile("outb %b0, %w1" ::"a"(data), "d"(port));
+		return;
+	}
+	if (size == 2) {
+		// Writes 2 bytes from AX to the port in DX.
+		asm volatile("outw %w0, %w1" ::"a"(data), "d"(port));
+		return;
+	}
+	if (size == 4) {
+		// Writes 4 bytes from EAX to the port in DX.
+		asm volatile("outl %k0, %w1" ::"a"(data), "d"(port));
+		return;
 	}
 }
diff --git a/executor/common_kvm_arm64.h b/executor/common_kvm_arm64.h
index 97a6429fe..4428a3484 100644
--- a/executor/common_kvm_arm64.h
+++ b/executor/common_kvm_arm64.h
@@ -6,6 +6,7 @@
 // Implementation of syz_kvm_setup_cpu pseudo-syscall.
 #include <sys/mman.h>
 
+#include "common_kvm.h"
 #include "kvm.h"
 
 #if SYZ_EXECUTOR || __NR_syz_kvm_setup_cpu || __NR_syz_kvm_add_vcpu || __NR_syz_kvm_setup_syzos_vm
diff --git a/executor/common_kvm_arm64_syzos.h b/executor/common_kvm_arm64_syzos.h
index 41a7f184b..2dd00a146 100644
--- a/executor/common_kvm_arm64_syzos.h
+++ b/executor/common_kvm_arm64_syzos.h
@@ -3,21 +3,11 @@
 
 // This file provides guest code running inside the ARM64 KVM.
 
+#include "common_kvm_syzos.h"
 #include "kvm.h"
 #include <linux/kvm.h>
 #include <stdbool.h>
 
-// Host will map the code in this section into the guest address space.
-#define GUEST_CODE __attribute__((section("guest")))
-
-// Prevent function inlining. This attribute is applied to every guest_handle_* function,
-// making sure they remain small so that the compiler does not attempt to be too clever
-// (e.g. generate switch tables).
-#define noinline __attribute__((noinline))
-
-// Start/end of the guest section.
-extern char *__start_guest, *__stop_guest;
-
 // Compilers will eagerly try to transform the switch statement in guest_main()
 // into a jump table, unless the cases are sparse enough.
 // We use prime numbers multiplied by 10 to prevent this behavior.
@@ -1201,7 +1191,8 @@ GUEST_CODE static void its_send_movall_cmd(uint64 cmdq_base, uint32 vcpu_id, uin
 	its_send_cmd(cmdq_base, &cmd);
 }
 
-GUEST_CODE static void its_send_invall_cmd(uint64 cmdq_base, uint32 collection_id)
+GUEST_CODE static void
+its_send_invall_cmd(uint64 cmdq_base, uint32 collection_id)
 {
 	struct its_cmd_block cmd;
 	guest_memzero(&cmd, sizeof(cmd));
diff --git a/executor/common_kvm_syzos.h b/executor/common_kvm_syzos.h
new file mode 100644
index 000000000..a635d517b
--- /dev/null
+++ b/executor/common_kvm_syzos.h
@@ -0,0 +1,33 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+// Common SYZOS definitions.
+
+// Prevent function inlining. This attribute is applied to every guest_handle_* function,
+// making sure they remain small so that the compiler does not attempt to be too clever
+// (e.g. generate switch tables).
+#define noinline __attribute__((noinline))
+
+// __no_stack_protector disables -fstack-protector which may introduce unwanted global accesses.
+// TODO(glider): once syz-env-old migrates to GCC>11 we can just use
+// __attribute__((no_stack_protector)).
+#if defined(__clang__)
+// Clang supports the no_stack_protector attribute.
+#define __no_stack_protector __attribute__((no_stack_protector))
+#elif defined(__GNUC__)
+// The no_stack_protector attribute was introduced in GCC 11.1.
+#if __GNUC__ > 11
+#define __no_stack_protector __attribute__((no_stack_protector))
+#else
+// Fallback to the optimize attribute for older GCC versions.
+#define __no_stack_protector __attribute__((__optimize__("-fno-stack-protector")))
+#endif
+#else
+#define __no_stack_protector
+#endif
+
+// Host will map the code in this section into the guest address space.
+#define GUEST_CODE __attribute__((section("guest"))) __no_stack_protector
+
+// Start/end of the guest section.
+extern char *__start_guest, *__stop_guest;
diff --git a/executor/common_linux.h b/executor/common_linux.h
index dea1ba0c8..5d477a16a 100644
--- a/executor/common_linux.h
+++ b/executor/common_linux.h
@@ -3187,7 +3187,7 @@ error_clear_loop:
 }
 #endif
 
-#if SYZ_EXECUTOR || __NR_syz_kvm_setup_cpu || __NR_syz_kvm_vgic_v3_setup || __NR_syz_kvm_setup_syzos_vm || __NR_syz_kvm_add_vcpu || __NR_syz_kvm_assert_syzos_uexit || __NR_syz_kvm_assert_reg
+#if SYZ_EXECUTOR || __NR_syz_kvm_setup_cpu || __NR_syz_kvm_vgic_v3_setup || __NR_syz_kvm_setup_syzos_vm || __NR_syz_kvm_add_vcpu || __NR_syz_kvm_assert_syzos_uexit || __NR_syz_kvm_assert_reg || __NR_syz_kvm_assert_syzos_kvm_exit
 // KVM is not yet supported on RISC-V
 #if !GOARCH_riscv64 && !GOARCH_arm
 #include <errno.h>
@@ -5852,3 +5852,57 @@ static long syz_pidfd_open(volatile long pid, volatile long flags)
 }
 
 #endif
+
+#if SYZ_EXECUTOR || __NR_syz_kfuzztest_run
+
+#include <fcntl.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+static long syz_kfuzztest_run(volatile long test_name_ptr, volatile long input_data,
+			      volatile long input_data_size, volatile long buffer)
+{
+	const char* test_name = (const char*)test_name_ptr;
+	if (!test_name) {
+		debug("syz_kfuzztest_run: test name was NULL\n");
+		return -1;
+	}
+	if (!buffer) {
+		debug("syz_kfuzztest_run: buffer was NULL\n");
+		return -1;
+	}
+
+	char buf[256];
+	int ret = snprintf(buf, sizeof(buf), "/sys/kernel/debug/kfuzztest/%s/input", test_name);
+	if (ret < 0 || (unsigned long)ret >= sizeof(buf)) {
+		debug("syz_kfuzztest_run: constructed path is too long or snprintf failed\n");
+		return -1;
+	}
+
+	int fd = openat(AT_FDCWD, buf, O_WRONLY, 0);
+	if (fd < 0) {
+		debug("syz_kfuzztest_run: failed to open %s\n", buf);
+		return -1;
+	}
+
+	ssize_t bytes_written = write(fd, (void*)buffer, (size_t)input_data_size);
+	if (bytes_written != input_data_size) {
+		debug("syz_kfuzztest_run: failed to write to %s, reason: %s\n", buf, strerror(errno));
+		close(fd);
+		return -1;
+	}
+
+	if (close(fd) != 0) {
+		debug("syz_kfuzztest_run: failed to close file\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+#endif
diff --git a/pkg/compiler/testdata/all.txt b/pkg/compiler/testdata/all.txt
index 1202e7511..cf6f3594c 100644
--- a/pkg/compiler/testdata/all.txt
+++ b/pkg/compiler/testdata/all.txt
@@ -339,6 +339,7 @@ flags_with_one_value = 0
 # Syscall attributes.
 
 fsck_test() (fsck["fsck.test -n"])
+foo_no_squash() (no_squash)
 
 # Compressed images.
 
diff --git a/pkg/corpus/corpus.go b/pkg/corpus/corpus.go
index bf99957c1..44ed16629 100644
--- a/pkg/corpus/corpus.go
+++ b/pkg/corpus/corpus.go
@@ -264,3 +264,7 @@ func (corpus *Corpus) ProgsPerArea() map[string]int {
 	}
 	return ret
 }
+
+func (corpus *Corpus) Cover() []uint64 {
+	return corpus.cover.Serialize()
+}
diff --git a/pkg/fuzzer/fuzzer.go b/pkg/fuzzer/fuzzer.go
index 0c0119e71..fdfe95518 100644
--- a/pkg/fuzzer/fuzzer.go
+++ b/pkg/fuzzer/fuzzer.go
@@ -72,6 +72,13 @@ func NewFuzzer(ctx context.Context, cfg *Config, rnd *rand.Rand,
 	return f
 }
 
+func (fuzzer *Fuzzer) RecommendedCalls() int {
+	if fuzzer.Config.ModeKFuzzTest {
+		return prog.RecommendedCallsKFuzzTest
+	}
+	return prog.RecommendedCalls
+}
+
 type execQueues struct {
 	triageCandidateQueue *queue.DynamicOrderer
 	candidateQueue       *queue.PlainQueue
@@ -214,6 +221,7 @@ type Config struct {
 	FetchRawCover  bool
 	NewInputFilter func(call string) bool
 	PatchTest      bool
+	ModeKFuzzTest  bool
 }
 
 func (fuzzer *Fuzzer) triageProgCall(p *prog.Prog, info *flatrpc.CallInfo, call int, triage *map[int]*triageCall) {
diff --git a/pkg/fuzzer/job.go b/pkg/fuzzer/job.go
index 7f1e47bf6..bbac544f6 100644
--- a/pkg/fuzzer/job.go
+++ b/pkg/fuzzer/job.go
@@ -43,7 +43,7 @@ func (ji *JobInfo) ID() string {
 
 func genProgRequest(fuzzer *Fuzzer, rnd *rand.Rand) *queue.Request {
 	p := fuzzer.target.Generate(rnd,
-		prog.RecommendedCalls,
+		fuzzer.RecommendedCalls(),
 		fuzzer.ChoiceTable())
 	return &queue.Request{
 		Prog:     p,
diff --git a/pkg/kcov/cdefs.go b/pkg/kcov/cdefs.go
new file mode 100644
index 000000000..1272360b9
--- /dev/null
+++ b/pkg/kcov/cdefs.go
@@ -0,0 +1,45 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package kcov
+
+// This file defines values required for KCOV ioctl calls. More information on
+// the values and their semantics can be found in the kernel documentation under
+// Documentation/dev-tools/kcov.rst, or at docs.kernel.org/dev-tools/kcov.html.
+
+import "unsafe"
+
+const (
+	sizeofUintPtr = int(unsafe.Sizeof((*int)(nil)))
+
+	iocNrBits   = 8
+	iocTypeBits = 8
+	iocSizeBits = 14
+	iocDirBits  = 2
+
+	iocNrShift   = 0
+	iocTypeshift = iocNrShift + iocNrBits
+	iocSizeShift = iocTypeshift + iocTypeBits
+	iocDirShift  = iocSizeShift + iocSizeBits
+
+	iocNone  = 0
+	iocWrite = 1
+	iocRead  = 2
+
+	// kcovInitTrace initializes KCOV tracing.
+	// #define kcovInitTrace _IOR('c', 1, unsigned long)
+	kcovInitTrace uintptr = (iocRead << iocDirShift) |
+		(unsafe.Sizeof(uint64(0)) << iocSizeShift) | ('c' << iocTypeshift) | (1 << iocNrShift) // 0x80086301.
+
+	// kcovEnable enables kcov for the current thread.
+	// #define kcovEnable _IO('c', 100)
+	kcovEnable uintptr = (iocNone << iocDirShift) |
+		(0 << iocSizeShift) | ('c' << iocTypeshift) | (100 << iocNrShift) // 0x6364.
+
+	// kcovDisable disables kcov for the current thread.
+	// #define kcovDisable _IO('c', 101)
+	kcovDisable uintptr = (iocNone << iocDirShift) |
+		(0 << iocSizeShift) | ('c' << iocTypeshift) | (101 << iocNrShift) // 0x6365.
+
+	kcovTracePC  = 0
+	kcovTraceCMP = 1
+)
diff --git a/pkg/kcov/kcov.go b/pkg/kcov/kcov.go
new file mode 100644
index 000000000..0400a32ff
--- /dev/null
+++ b/pkg/kcov/kcov.go
@@ -0,0 +1,115 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+//go:build linux
+
+// Package kcov provides Go native code for collecting kernel coverage (KCOV)
+// information.
+package kcov
+
+import (
+	"os"
+	"runtime"
+	"sync/atomic"
+	"unsafe"
+
+	"golang.org/x/sys/unix"
+)
+
+const (
+	kcovPath = "/sys/kernel/debug/kcov"
+	// This is the same value used by the linux executor, see executor_linux.h.
+	kcovCoverSize = 512 << 10
+)
+
+// Holds resources for a single traced thread.
+type KCOVState struct {
+	file  *os.File
+	cover []byte
+}
+
+type KCOVTraceResult struct {
+	Result   error     // Result of the call.
+	Coverage []uintptr // Collected program counters.
+}
+
+// Trace invokes `f` and returns a KCOVTraceResult.
+func (st *KCOVState) Trace(f func() error) KCOVTraceResult {
+	// First 8 bytes holds the number of collected PCs since last poll.
+	countPtr := (*uintptr)(unsafe.Pointer(&st.cover[0]))
+	// Reset coverage for this run.
+	atomic.StoreUintptr(countPtr, 0)
+	// Trigger call.
+	err := f()
+	// Load the number of PCs that were hit during trigger.
+	n := atomic.LoadUintptr(countPtr)
+
+	pcDataPtr := (*uintptr)(unsafe.Pointer(&st.cover[sizeofUintPtr]))
+	pcs := unsafe.Slice(pcDataPtr, n)
+	pcsCopy := make([]uintptr, n)
+	copy(pcsCopy, pcs)
+	return KCOVTraceResult{Result: err, Coverage: pcsCopy}
+}
+
+// EnableTracingForCurrentGoroutine prepares the current goroutine for kcov tracing.
+// It must be paired with a call to DisableTracing.
+func EnableTracingForCurrentGoroutine() (st *KCOVState, err error) {
+	st = &KCOVState{}
+	defer func() {
+		if err != nil {
+			// The original error is more important, so we ignore any potential
+			// errors that result from cleaning up.
+			_ = st.DisableTracing()
+		}
+	}()
+
+	// KCOV is per-thread, so lock goroutine to its current OS thread.
+	runtime.LockOSThread()
+
+	file, err := os.OpenFile(kcovPath, os.O_RDWR, 0)
+	if err != nil {
+		return nil, err
+	}
+	st.file = file
+
+	// Setup trace mode and size.
+	if err := unix.IoctlSetInt(int(st.file.Fd()), uint(kcovInitTrace), kcovCoverSize); err != nil {
+		return nil, err
+	}
+
+	// Mmap buffer shared between kernel- and user-space. For more information,
+	// see the Linux KCOV documentation: https://docs.kernel.org/dev-tools/kcov.html.
+	st.cover, err = unix.Mmap(
+		int(st.file.Fd()),
+		0, // Offset.
+		kcovCoverSize*sizeofUintPtr,
+		unix.PROT_READ|unix.PROT_WRITE,
+		unix.MAP_SHARED,
+	)
+	if err != nil {
+		return nil, err
+	}
+
+	// Enable coverage collection on the current thread.
+	if err := unix.IoctlSetInt(int(st.file.Fd()), uint(kcovEnable), kcovTracePC); err != nil {
+		return nil, err
+	}
+	return st, nil
+}
+
+// DisableTracing disables KCOV tracing for the current Go routine. On failure,
+// it returns the first error that occurred during cleanup.
+func (st *KCOVState) DisableTracing() error {
+	var firstErr error
+	if err := unix.IoctlSetInt(int(st.file.Fd()), uint(kcovDisable), kcovTracePC); err != nil {
+		firstErr = err
+	}
+	if err := unix.Munmap(st.cover); err != nil && firstErr == nil {
+		firstErr = err
+	}
+	if err := st.file.Close(); err != nil && firstErr == nil {
+		firstErr = err
+	}
+	runtime.UnlockOSThread()
+	return firstErr
+}
diff --git a/pkg/kfuzztest-executor/executor.go b/pkg/kfuzztest-executor/executor.go
new file mode 100644
index 000000000..4637ba553
--- /dev/null
+++ b/pkg/kfuzztest-executor/executor.go
@@ -0,0 +1,123 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+//go:build linux
+
+// Package kfuzztestexecutor implements local execution (i.e., without the
+// C++ executor program) for KFuzzTest targets.
+package kfuzztestexecutor
+
+import (
+	"context"
+	"fmt"
+	"sync"
+	"time"
+
+	"github.com/google/syzkaller/pkg/flatrpc"
+	"github.com/google/syzkaller/pkg/fuzzer/queue"
+	"github.com/google/syzkaller/pkg/kcov"
+	"github.com/google/syzkaller/pkg/kfuzztest"
+	"github.com/google/syzkaller/pkg/log"
+	"github.com/google/syzkaller/pkg/osutil"
+	"github.com/google/syzkaller/prog"
+)
+
+// KFuzzTestExecutor is an executor that upon receiving a request, will invoke
+// a KFuzzTest target.
+type KFuzzTestExecutor struct {
+	ctx     context.Context
+	jobChan chan *queue.Request
+	// Cooldown between execution requests.
+	cooldown time.Duration
+	wg       sync.WaitGroup
+}
+
+// Implements the queue.Executor interface.
+func (kfe *KFuzzTestExecutor) Submit(req *queue.Request) {
+	kfe.jobChan <- req
+}
+
+func (kfe *KFuzzTestExecutor) Shutdown() {
+	close(kfe.jobChan)
+	kfe.wg.Wait()
+}
+
+func NewKFuzzTestExecutor(ctx context.Context, numWorkers int, cooldown uint32) *KFuzzTestExecutor {
+	jobChan := make(chan *queue.Request)
+
+	kfe := &KFuzzTestExecutor{
+		ctx:      ctx,
+		jobChan:  jobChan,
+		cooldown: time.Duration(cooldown) * time.Second,
+	}
+
+	kfe.wg.Add(numWorkers)
+	for i := range numWorkers {
+		go kfe.workerLoop(i)
+	}
+	return kfe
+}
+
+func (kfe *KFuzzTestExecutor) workerLoop(tid int) {
+	defer kfe.wg.Done()
+	kcovSt, err := kcov.EnableTracingForCurrentGoroutine()
+	if err != nil {
+		log.Logf(1, "failed to enable kcov for thread_%d", tid)
+		return
+	}
+	defer kcovSt.DisableTracing()
+
+	for req := range kfe.jobChan {
+		if req.Prog == nil {
+			log.Logf(1, "thread_%d: exec request had nil program", tid)
+		}
+
+		info := new(flatrpc.ProgInfo)
+		for _, call := range req.Prog.Calls {
+			callInfo := new(flatrpc.CallInfo)
+
+			// Trace each individual call, collecting the covered PCs.
+			coverage, err := execKFuzzTestCallLocal(kcovSt, call)
+			if err != nil {
+				// Set this call info as a failure. -1 is a placeholder.
+				callInfo.Error = -1
+				callInfo.Flags |= flatrpc.CallFlagBlocked
+			} else {
+				for _, pc := range coverage {
+					callInfo.Signal = append(callInfo.Signal, uint64(pc))
+					callInfo.Cover = append(callInfo.Cover, uint64(pc))
+				}
+				callInfo.Flags |= flatrpc.CallFlagExecuted
+			}
+
+			info.Calls = append(info.Calls, callInfo)
+		}
+
+		req.Done(&queue.Result{Info: info, Executor: queue.ExecutorID{VM: 0, Proc: tid}})
+
+		if kfe.cooldown != 0 {
+			time.Sleep(kfe.cooldown)
+		}
+	}
+	log.Logf(0, "thread_%d exiting", tid)
+}
+
+func execKFuzzTestCallLocal(st *kcov.KCOVState, call *prog.Call) ([]uintptr, error) {
+	if !call.Meta.Attrs.KFuzzTest {
+		return []uintptr{}, fmt.Errorf("call is not a KFuzzTest call")
+	}
+	testName, isKFuzzTest := kfuzztest.GetTestName(call.Meta)
+	if !isKFuzzTest {
+		return []uintptr{}, fmt.Errorf("tried to execute a syscall that wasn't syz_kfuzztest_run")
+	}
+
+	dataArg, ok := call.Args[1].(*prog.PointerArg)
+	if !ok {
+		return []uintptr{}, fmt.Errorf("second arg for syz_kfuzztest_run should be a pointer")
+	}
+	finalBlob := prog.MarshallKFuzztestArg(dataArg.Res)
+	inputPath := kfuzztest.GetInputFilepath(testName)
+
+	res := st.Trace(func() error { return osutil.WriteFile(inputPath, finalBlob) })
+	return res.Coverage, res.Result
+}
diff --git a/pkg/kfuzztest-manager/manager.go b/pkg/kfuzztest-manager/manager.go
new file mode 100644
index 000000000..f728230cc
--- /dev/null
+++ b/pkg/kfuzztest-manager/manager.go
@@ -0,0 +1,201 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package kfuzztestmanager
+
+import (
+	"context"
+	"fmt"
+	"math/rand"
+	"os"
+	"slices"
+	"strings"
+	"sync"
+	"sync/atomic"
+	"time"
+
+	"github.com/google/syzkaller/pkg/corpus"
+	"github.com/google/syzkaller/pkg/fuzzer"
+	"github.com/google/syzkaller/pkg/fuzzer/queue"
+	"github.com/google/syzkaller/pkg/kfuzztest"
+	executor "github.com/google/syzkaller/pkg/kfuzztest-executor"
+	"github.com/google/syzkaller/pkg/log"
+	"github.com/google/syzkaller/pkg/mgrconfig"
+	"github.com/google/syzkaller/pkg/stat"
+	"github.com/google/syzkaller/prog"
+	"github.com/google/syzkaller/sys/targets"
+)
+
+type kFuzzTestManager struct {
+	fuzzer atomic.Pointer[fuzzer.Fuzzer]
+	source queue.Source
+	target *prog.Target
+	config Config
+}
+
+type Config struct {
+	VmlinuxPath     string
+	Cooldown        uint32
+	DisplayInterval uint32
+	NumThreads      int
+	EnabledTargets  []string
+}
+
+func NewKFuzzTestManager(ctx context.Context, cfg Config) (*kFuzzTestManager, error) {
+	var mgr kFuzzTestManager
+
+	target, err := prog.GetTarget(targets.Linux, targets.AMD64)
+	if err != nil {
+		return nil, err
+	}
+
+	log.Logf(0, "extracting KFuzzTest targets from \"%s\" (this will take a few seconds)", cfg.VmlinuxPath)
+	calls, err := kfuzztest.ActivateKFuzzTargets(target, cfg.VmlinuxPath)
+	if err != nil {
+		return nil, err
+	}
+
+	enabledCalls := make(map[*prog.Syscall]bool)
+	for _, call := range calls {
+		enabledCalls[call] = true
+	}
+
+	// Disable all calls that weren't explicitly enabled.
+	if len(cfg.EnabledTargets) > 0 {
+		enabledMap := make(map[string]bool)
+		for _, enabled := range cfg.EnabledTargets {
+			enabledMap[enabled] = true
+		}
+		for syscall := range enabledCalls {
+			testName, isSyzKFuzzTest := kfuzztest.GetTestName(syscall)
+			_, isEnabled := enabledMap[testName]
+			if isSyzKFuzzTest && syscall.Attrs.KFuzzTest && isEnabled {
+				enabledMap[testName] = true
+			} else {
+				delete(enabledCalls, syscall)
+			}
+		}
+	}
+
+	dispDiscoveredTargets := func() string {
+		var builder strings.Builder
+		totalEnabled := 0
+
+		builder.WriteString("enabled KFuzzTest targets: [\n")
+		for targ, enabled := range enabledCalls {
+			if enabled {
+				fmt.Fprintf(&builder, "\t%s,\n", targ.Name)
+				totalEnabled++
+			}
+		}
+		fmt.Fprintf(&builder, "]\ntotal = %d\n", totalEnabled)
+		return builder.String()
+	}
+	log.Logf(0, "%s", dispDiscoveredTargets())
+
+	corpus := corpus.NewCorpus(ctx)
+	rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
+	fuzzerObj := fuzzer.NewFuzzer(ctx, &fuzzer.Config{
+		Corpus:         corpus,
+		Snapshot:       false,
+		Coverage:       true,
+		FaultInjection: false,
+		Comparisons:    false,
+		Collide:        false,
+		EnabledCalls:   enabledCalls,
+		NoMutateCalls:  make(map[int]bool),
+		FetchRawCover:  false,
+		Logf: func(level int, msg string, args ...any) {
+			if level != 0 {
+				return
+			}
+			log.Logf(level, msg, args...)
+		},
+		NewInputFilter: func(call string) bool {
+			// Don't filter anything.
+			return true
+		},
+	}, rnd, target)
+
+	// TODO: Sufficient for startup, but not ideal that we are passing a
+	// manager config here. Would require changes to pkg/fuzzer if we wanted to
+	// avoid the dependency.
+	execOpts := fuzzer.DefaultExecOpts(&mgrconfig.Config{Sandbox: "none"}, 0, false)
+
+	mgr.target = target
+	mgr.fuzzer.Store(fuzzerObj)
+	mgr.source = queue.DefaultOpts(fuzzerObj, execOpts)
+	mgr.config = cfg
+
+	return &mgr, nil
+}
+
+func (mgr *kFuzzTestManager) Run(ctx context.Context) {
+	var wg sync.WaitGroup
+
+	// Launches the executor threads.
+	executor := executor.NewKFuzzTestExecutor(ctx, mgr.config.NumThreads, mgr.config.Cooldown)
+
+	// Display logs periodically.
+	display := func() {
+		defer wg.Done()
+		mgr.displayLoop(ctx)
+	}
+
+	wg.Add(1)
+	go display()
+
+FuzzLoop:
+	for {
+		select {
+		case <-ctx.Done():
+			break FuzzLoop
+		default:
+		}
+
+		req := mgr.source.Next()
+		if req == nil {
+			continue
+		}
+
+		executor.Submit(req)
+	}
+
+	log.Log(0, "fuzzing finished, shutting down executor")
+	executor.Shutdown()
+	wg.Wait()
+
+	const filepath string = "pcs.out"
+	log.Logf(0, "writing PCs out to \"%s\"", filepath)
+	if err := mgr.writePCs(filepath); err != nil {
+		log.Logf(0, "failed to write PCs: %v", err)
+	}
+
+	log.Log(0, "KFuzzTest manager exited")
+}
+
+func (mgr *kFuzzTestManager) writePCs(filepath string) error {
+	pcs := mgr.fuzzer.Load().Config.Corpus.Cover()
+	slices.Sort(pcs)
+	var builder strings.Builder
+	for _, pc := range pcs {
+		fmt.Fprintf(&builder, "0x%x\n", pc)
+	}
+	return os.WriteFile(filepath, []byte(builder.String()), 0644)
+}
+
+func (mgr *kFuzzTestManager) displayLoop(ctx context.Context) {
+	ticker := time.NewTicker(time.Duration(mgr.config.DisplayInterval) * time.Second)
+	defer ticker.Stop()
+	for {
+		var buf strings.Builder
+		select {
+		case <-ctx.Done():
+			return
+		case <-ticker.C:
+			for _, stat := range stat.Collect(stat.Console) {
+				fmt.Fprintf(&buf, "%v=%v ", stat.Name, stat.Value)
+			}
+			log.Log(0, buf.String())
+		}
+	}
+}
diff --git a/pkg/kfuzztest/builder.go b/pkg/kfuzztest/builder.go
new file mode 100644
index 000000000..7262fd776
--- /dev/null
+++ b/pkg/kfuzztest/builder.go
@@ -0,0 +1,255 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package kfuzztest
+
+import (
+	"debug/dwarf"
+	"fmt"
+	"strings"
+
+	"github.com/google/syzkaller/pkg/ast"
+)
+
+type Builder struct {
+	funcs       []SyzFunc
+	structs     []SyzStruct
+	constraints []SyzConstraint
+	annotations []SyzAnnotation
+}
+
+func NewBuilder(
+	funcs []SyzFunc,
+	structs []SyzStruct,
+	constraints []SyzConstraint,
+	annotations []SyzAnnotation,
+) *Builder {
+	return &Builder{funcs, structs, constraints, annotations}
+}
+
+func (b *Builder) AddStruct(s SyzStruct) {
+	b.structs = append(b.structs, s)
+}
+
+func (b *Builder) AddFunc(f SyzFunc) {
+	b.funcs = append(b.funcs, f)
+}
+
+func (b *Builder) EmitSyzlangDescription() (string, error) {
+	constraintMap := make(map[string]map[string]SyzConstraint)
+	for _, constraint := range b.constraints {
+		if _, contains := constraintMap[constraint.InputType]; !contains {
+			constraintMap[constraint.InputType] = make(map[string]SyzConstraint)
+		}
+		constraintMap[constraint.InputType][constraint.FieldName] = constraint
+	}
+	annotationMap := make(map[string]map[string]SyzAnnotation)
+	for _, annotation := range b.annotations {
+		if _, contains := annotationMap[annotation.InputType]; !contains {
+			annotationMap[annotation.InputType] = make(map[string]SyzAnnotation)
+		}
+		annotationMap[annotation.InputType][annotation.FieldName] = annotation
+	}
+
+	var descBuilder strings.Builder
+	descBuilder.WriteString("# This description was automatically generated with tools/kfuzztest-gen\n")
+	for _, s := range b.structs {
+		structDesc, err := syzStructToSyzlang(s, constraintMap, annotationMap)
+		if err != nil {
+			return "", err
+		}
+		descBuilder.WriteString(structDesc)
+		descBuilder.WriteString("\n\n")
+	}
+
+	for i, fn := range b.funcs {
+		descBuilder.WriteString(syzFuncToSyzlang(fn))
+		if i < len(b.funcs)-1 {
+			descBuilder.WriteString("\n")
+		}
+	}
+
+	// Format the output syzlang descriptions for consistency.
+	var astError error
+	eh := func(pos ast.Pos, msg string) {
+		astError = fmt.Errorf("ast failure: %v: %v", pos, msg)
+	}
+	descAst := ast.Parse([]byte(descBuilder.String()), "", eh)
+	if astError != nil {
+		return "", astError
+	}
+	if descAst == nil {
+		return "", fmt.Errorf("failed to format generated syzkaller description - is it well-formed?")
+	}
+	return string(ast.Format(descAst)), nil
+}
+
+func syzStructToSyzlang(s SyzStruct, constraintMap map[string]map[string]SyzConstraint,
+	annotationMap map[string]map[string]SyzAnnotation) (string, error) {
+	var builder strings.Builder
+
+	fmt.Fprintf(&builder, "%s {\n", s.Name)
+	structAnnotations := annotationMap["struct "+s.Name]
+	structConstraints := constraintMap["struct "+s.Name]
+	for _, field := range s.Fields {
+		line, err := syzFieldToSyzLang(field, structConstraints, structAnnotations)
+		if err != nil {
+			return "", err
+		}
+		fmt.Fprintf(&builder, "\t%s\n", line)
+	}
+	fmt.Fprint(&builder, "}")
+	return builder.String(), nil
+}
+
+func syzFieldToSyzLang(field SyzField, constraintMap map[string]SyzConstraint,
+	annotationMap map[string]SyzAnnotation) (string, error) {
+	constraint, hasConstraint := constraintMap[field.Name]
+	annotation, hasAnnotation := annotationMap[field.Name]
+
+	var typeDesc string
+	var err error
+	if hasAnnotation {
+		// Annotations override the existing type definitions.
+		typeDesc, err = processAnnotation(field, annotation)
+	} else {
+		typeDesc, err = dwarfToSyzlangType(field.dwarfType)
+	}
+	if err != nil {
+		return "", err
+	}
+
+	// Process constraints only if unannotated.
+	// TODO: is there a situation where we would want to process both?
+	if hasConstraint && !hasAnnotation {
+		constraint, err := processConstraint(constraint)
+		if err != nil {
+			return "", err
+		}
+		typeDesc += constraint
+	}
+	return fmt.Sprintf("%s %s", field.Name, typeDesc), nil
+}
+
+func processConstraint(c SyzConstraint) (string, error) {
+	switch c.ConstraintType {
+	case ExpectEq:
+		return fmt.Sprintf("[%d]", c.Value1), nil
+	case ExpectNe:
+		// syzkaller does not have a built-in way to support an inequality
+		// constraint AFAIK.
+		return "", nil
+	case ExpectLt:
+		return fmt.Sprintf("[0:%d]", c.Value1-1), nil
+	case ExpectLe:
+		return fmt.Sprintf("[0:%d]", c.Value1), nil
+	case ExpectGt:
+		return fmt.Sprintf("[%d]", c.Value1+1), nil
+	case ExpectGe:
+		return fmt.Sprintf("[%d]", c.Value1), nil
+	case ExpectInRange:
+		return fmt.Sprintf("[%d:%d]", c.Value1, c.Value2), nil
+	default:
+		fmt.Printf("c = %d\n", c.ConstraintType)
+		return "", fmt.Errorf("unsupported constraint type")
+	}
+}
+
+func processAnnotation(field SyzField, annotation SyzAnnotation) (string, error) {
+	switch annotation.Attribute {
+	case AttributeLen:
+		underlyingType, err := dwarfToSyzlangType(field.dwarfType)
+		if err != nil {
+			return "", err
+		}
+		return fmt.Sprintf("len[%s, %s]", annotation.LinkedFieldName, underlyingType), nil
+	case AttributeString:
+		return "ptr[in, string]", nil
+	case AttributeArray:
+		pointeeType, isPtr := resolvesToPtr(field.dwarfType)
+		if !isPtr {
+			return "", fmt.Errorf("can only annotate pointer fields are arrays")
+		}
+		// TODO: discards const qualifier.
+		typeDesc, err := dwarfToSyzlangType(pointeeType)
+		if err != nil {
+			return "", err
+		}
+		return fmt.Sprintf("ptr[in, array[%s]]", typeDesc), nil
+	default:
+		return "", fmt.Errorf("unsupported attribute type")
+	}
+}
+
+// Returns true iff `dwarfType` resolved down to a pointer. For example,
+// a `const *void` which isn't directly a pointer.
+func resolvesToPtr(dwarfType dwarf.Type) (dwarf.Type, bool) {
+	switch t := dwarfType.(type) {
+	case *dwarf.QualType:
+		return resolvesToPtr(t.Type)
+	case *dwarf.PtrType:
+		return t.Type, true
+	}
+	return nil, false
+}
+
+func syzFuncToSyzlang(s SyzFunc) string {
+	var builder strings.Builder
+	typeName := strings.TrimPrefix(s.InputStructName, "struct ")
+
+	fmt.Fprintf(&builder, "syz_kfuzztest_run$%s(", s.Name)
+	fmt.Fprintf(&builder, "name ptr[in, string[\"%s\"]], ", s.Name)
+	fmt.Fprintf(&builder, "data ptr[in, %s], ", typeName)
+	builder.WriteString("len bytesize[data], ")
+	builder.WriteString("buf ptr[in, array[int8, 65536]]) ")
+	// TODO:(ethangraham) The only other way I can think of getting this name
+	// would involve using the "reflect" package and matching against the
+	// KFuzzTest name, which isn't much better than hardcoding this.
+	builder.WriteString("(kfuzz_test)")
+	return builder.String()
+}
+
+// Given a dwarf type, returns a syzlang string representation of this type.
+func dwarfToSyzlangType(dwarfType dwarf.Type) (string, error) {
+	switch t := dwarfType.(type) {
+	case *dwarf.PtrType:
+		underlyingType, err := dwarfToSyzlangType(t.Type)
+		if err != nil {
+			return "", err
+		}
+		return fmt.Sprintf("ptr[in, %s]", underlyingType), nil
+	case *dwarf.QualType:
+		if t.Qual == "const" {
+			return dwarfToSyzlangType(t.Type)
+		} else {
+			return "", fmt.Errorf("no support for %s qualifier", t.Qual)
+		}
+	case *dwarf.ArrayType:
+		underlyingType, err := dwarfToSyzlangType(t.Type)
+		if err != nil {
+			return "", err
+		}
+		// If t.Count == -1 then this is a varlen array as per debug/dwarf
+		// documentation.
+		if t.Count == -1 {
+			return fmt.Sprintf("array[%s]", underlyingType), nil
+		} else {
+			return fmt.Sprintf("array[%s, %d]", underlyingType, t.Count), nil
+		}
+	case *dwarf.TypedefType:
+		return dwarfToSyzlangType(t.Type)
+	case *dwarf.IntType, *dwarf.UintType:
+		numBits := t.Size() * 8
+		return fmt.Sprintf("int%d", numBits), nil
+	case *dwarf.CharType, *dwarf.UcharType:
+		return "int8", nil
+	// `void` isn't a valid type by itself, so we know that it would have
+	// been wrapped in a pointer, e.g., `void *`. For this reason, we can return
+	// just interpret it as a byte, i.e., int8.
+	case *dwarf.VoidType:
+		return "int8", nil
+	case *dwarf.StructType:
+		return strings.TrimPrefix(t.StructName, "struct "), nil
+	default:
+		return "", fmt.Errorf("unsupported type %s", dwarfType.String())
+	}
+}
diff --git a/pkg/kfuzztest/description_generation_test.go b/pkg/kfuzztest/description_generation_test.go
new file mode 100644
index 000000000..d68a96b18
--- /dev/null
+++ b/pkg/kfuzztest/description_generation_test.go
@@ -0,0 +1,103 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package kfuzztest
+
+import (
+	"fmt"
+	"os"
+	"path"
+	"testing"
+	"time"
+
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/syzkaller/pkg/osutil"
+	"github.com/google/syzkaller/sys/targets"
+	"github.com/stretchr/testify/require"
+)
+
+type testData struct {
+	dir  string
+	desc string
+}
+
+func TestBuildDescriptions(t *testing.T) {
+	testCases, err := readTestCases("./testdata")
+	require.NoError(t, err)
+
+	target := targets.Get(targets.Linux, targets.AMD64)
+	for _, tc := range testCases {
+		t.Run(tc.dir, func(t *testing.T) {
+			runTest(t, target, tc)
+		})
+	}
+}
+
+// Tests that the description inferred from a compiled binary matches an
+// expected description.
+func runTest(t *testing.T, target *targets.Target, tc testData) {
+	// Compile the C binary containing the metadata.
+	cmd := flags(tc.dir)
+	out, err := osutil.RunCmd(time.Hour, "", target.CCompiler, cmd...)
+	require.NoErrorf(t, err, "Failed to compile: %s", string(out))
+	// Cleanup the compiled binary.
+	defer func() {
+		out, err := osutil.RunCmd(time.Hour, "", "rm", path.Join(tc.dir, "bin"))
+		if err != nil {
+			require.NoErrorf(t, err, "Failed to cleanup: %s", string(out))
+		}
+	}()
+
+	binaryPath := path.Join(tc.dir, "bin")
+	desc, err := ExtractDescription(binaryPath)
+	require.NoError(t, err)
+
+	if diffDesc := cmp.Diff(tc.desc, desc); diffDesc != "" {
+		fmt.Print(diffDesc)
+		t.Fail()
+		return
+	}
+}
+
+func flags(testDir string) []string {
+	return []string{
+		"-g",
+		"-T",
+		path.Join(testDir, "..", "linker.ld"),
+		"-o",
+		path.Join(testDir, "bin"),
+		path.Join(testDir, "prog.c"),
+	}
+}
+
+func readTestCases(dir string) ([]testData, error) {
+	var testCases []testData
+	testDirs, err := os.ReadDir(dir)
+	if err != nil {
+		return nil, err
+	}
+
+	for _, subDir := range testDirs {
+		if !subDir.IsDir() {
+			continue
+		}
+		testData, err := readTestdata(path.Join(dir, subDir.Name()))
+		if err != nil {
+			return nil, err
+		}
+		testCases = append(testCases, testData)
+	}
+
+	return testCases, nil
+}
+
+func readTestdata(testDir string) (testData, error) {
+	content, err := os.ReadFile(path.Join(testDir, "desc.txt"))
+	if err != nil {
+		return testData{}, err
+	}
+
+	return testData{
+		dir:  testDir,
+		desc: string(content),
+	}, nil
+}
diff --git a/pkg/kfuzztest/extractor.go b/pkg/kfuzztest/extractor.go
new file mode 100644
index 000000000..e13ea4662
--- /dev/null
+++ b/pkg/kfuzztest/extractor.go
@@ -0,0 +1,435 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package kfuzztest
+
+import (
+	"debug/dwarf"
+	"debug/elf"
+	"fmt"
+	"strings"
+)
+
+// Extractor's job is to extract all information relevant to KFuzzTest from a
+// VMlinux binary.
+type Extractor struct {
+	// Path to the `vmlinux` being parsed.
+	vmlinuxPath string
+	elfFile     *elf.File
+	dwarfData   *dwarf.Data
+
+	// We use an index to avoid repeated sequential scans of the whole binary,
+	// as this is by far the most expensive operation.
+	symbolsIndexInitialized bool
+	symbolsIndex            map[string]elf.Symbol
+}
+
+func NewExtractor(vmlinuxPath string) (*Extractor, error) {
+	elfFile, err := elf.Open(vmlinuxPath)
+	if err != nil {
+		return nil, err
+	}
+	dwarfData, err := elfFile.DWARF()
+	if err != nil {
+		elfFile.Close()
+		return nil, err
+	}
+	return &Extractor{vmlinuxPath, elfFile, dwarfData, false, make(map[string]elf.Symbol)}, nil
+}
+
+type ExtractAllResult struct {
+	VMLinuxPath string
+	Funcs       []SyzFunc
+	Structs     []SyzStruct
+	Constraints []SyzConstraint
+	Annotations []SyzAnnotation
+}
+
+func (e *Extractor) ExtractAll() (ExtractAllResult, error) {
+	funcs, err := e.extractFuncs()
+	if err != nil {
+		return ExtractAllResult{}, err
+	}
+	structs, err := e.extractStructs(funcs)
+	if err != nil {
+		return ExtractAllResult{}, err
+	}
+	constraints, err := e.extractDomainConstraints()
+	if err != nil {
+		return ExtractAllResult{}, err
+	}
+	annotations, err := e.extractAnnotations()
+	if err != nil {
+		return ExtractAllResult{}, err
+	}
+
+	if len(structs) < len(funcs) {
+		return ExtractAllResult{}, fmt.Errorf("inconsistent KFuzzTest metadata found in vmlinux")
+	}
+	if len(funcs) == 0 {
+		return ExtractAllResult{}, nil
+	}
+
+	return ExtractAllResult{
+		VMLinuxPath: e.vmlinuxPath,
+		Funcs:       funcs,
+		Structs:     structs,
+		Constraints: constraints,
+		Annotations: annotations,
+	}, nil
+}
+
+func (e *Extractor) Close() {
+	e.elfFile.Close()
+}
+
+func (e *ExtractAllResult) String() string {
+	var builder strings.Builder
+
+	fmt.Fprint(&builder, "extraction result:\n")
+	fmt.Fprintf(&builder, "\tVMLinux image:   %s\n", e.VMLinuxPath)
+	fmt.Fprintf(&builder, "\tnum targets:     %d\n", len(e.Funcs))
+	fmt.Fprintf(&builder, "\tnum struct:      %d\n", len(e.Structs))
+	fmt.Fprintf(&builder, "\tnum constraints: %d\n", len(e.Constraints))
+	fmt.Fprintf(&builder, "\tnum annotations: %d\n", len(e.Annotations))
+
+	return builder.String()
+}
+
+// Given an address, returns the elf section that this address belongs to in
+// the Extractor's elf file.
+func (e *Extractor) elfSection(addr uint64) *elf.Section {
+	for _, section := range e.elfFile.Sections {
+		if addr >= section.Addr && addr < section.Addr+section.Size {
+			return section
+		}
+	}
+	return nil
+}
+
+// Reads a string of length at most 128 bytes from the Extractor's elf file.
+func (e *Extractor) readElfString(offset uint64) (string, error) {
+	strSection := e.elfSection(offset)
+	if strSection == nil {
+		return "", fmt.Errorf("unable to find section for offset 0x%X", offset)
+	}
+
+	// 128 bytes is longer than we expect to see in KFuzzTest metadata.
+	buffer := make([]byte, 128)
+	_, err := strSection.ReadAt(buffer, int64(offset-strSection.Addr))
+	if err != nil {
+		return "", err
+	}
+
+	var builder strings.Builder
+	for _, chr := range buffer {
+		if chr == 0 {
+			return builder.String(), nil
+		}
+		builder.WriteByte(chr)
+	}
+
+	return "", fmt.Errorf("could not find null-terminated string with length < 128")
+}
+
+func (e *Extractor) buildSymbolIndex() error {
+	symbols, err := e.elfFile.Symbols()
+	if err != nil {
+		return err
+	}
+	for _, sym := range symbols {
+		e.symbolsIndex[sym.Name] = sym
+	}
+	return nil
+}
+
+func (e *Extractor) getSymbol(symbolName string) (elf.Symbol, error) {
+	if !e.symbolsIndexInitialized {
+		err := e.buildSymbolIndex()
+		e.symbolsIndexInitialized = true
+		if err != nil {
+			return elf.Symbol{}, err
+		}
+	}
+
+	symbol, contains := e.symbolsIndex[symbolName]
+	if !contains {
+		return elf.Symbol{}, fmt.Errorf("symbol %s not found in %s", symbolName, e.vmlinuxPath)
+	}
+	return symbol, nil
+}
+
+func (e *Extractor) extractFuncs() ([]SyzFunc, error) {
+	var rawFuncs []*kfuzztestTarget
+	var err error
+
+	rawFuncs, err = parseKftfObjects[*kfuzztestTarget](e)
+	if err != nil {
+		return nil, err
+	}
+
+	fuzzTargets := make([]SyzFunc, len(rawFuncs))
+	for i, raw := range rawFuncs {
+		name, err := e.readElfString(raw.name)
+		if err != nil {
+			return []SyzFunc{}, err
+		}
+		argType, err := e.readElfString(raw.argType)
+		if err != nil {
+			return []SyzFunc{}, err
+		}
+		fuzzTargets[i] = SyzFunc{
+			Name:            name,
+			InputStructName: argType,
+		}
+	}
+
+	return fuzzTargets, nil
+}
+
+func (e *Extractor) extractDomainConstraints() ([]SyzConstraint, error) {
+	var rawConstraints []*kfuzztestConstraint
+	var err error
+
+	rawConstraints, err = parseKftfObjects[*kfuzztestConstraint](e)
+	if err != nil {
+		return nil, err
+	}
+
+	constraints := make([]SyzConstraint, len(rawConstraints))
+	for i, raw := range rawConstraints {
+		typeName, err := e.readElfString(raw.inputType)
+		if err != nil {
+			return []SyzConstraint{}, err
+		}
+		fieldName, err := e.readElfString(raw.fieldName)
+		if err != nil {
+			return []SyzConstraint{}, err
+		}
+
+		constraints[i] = SyzConstraint{
+			InputType:      typeName,
+			FieldName:      fieldName,
+			Value1:         raw.value1,
+			Value2:         raw.value2,
+			ConstraintType: ConstraintType(raw.constraintType),
+		}
+	}
+
+	return constraints, nil
+}
+
+func (e *Extractor) extractAnnotations() ([]SyzAnnotation, error) {
+	var rawAnnotations []*kfuzztestAnnotation
+	var err error
+
+	rawAnnotations, err = parseKftfObjects[*kfuzztestAnnotation](e)
+	if err != nil {
+		return nil, err
+	}
+
+	annotations := make([]SyzAnnotation, len(rawAnnotations))
+	for i, raw := range rawAnnotations {
+		typeName, err := e.readElfString(raw.inputType)
+		if err != nil {
+			return nil, err
+		}
+		fieldName, err := e.readElfString(raw.fieldName)
+		if err != nil {
+			return nil, err
+		}
+		linkedFieldName, err := e.readElfString(raw.linkedFieldName)
+		if err != nil {
+			return nil, err
+		}
+
+		annotations[i] = SyzAnnotation{
+			InputType:       typeName,
+			FieldName:       fieldName,
+			LinkedFieldName: linkedFieldName,
+			Attribute:       AnnotationAttribute(raw.annotationAttribute),
+		}
+	}
+
+	return annotations, nil
+}
+
+func (e *Extractor) dwarfGetType(entry *dwarf.Entry) (dwarf.Type, error) {
+	// Case 1: The entry is itself a type definition (e.g., TagStructType, TagBaseType).
+	// We use its own offset to get the dwarf.Type object.
+	switch entry.Tag {
+	case dwarf.TagStructType, dwarf.TagBaseType, dwarf.TagTypedef, dwarf.TagPointerType, dwarf.TagArrayType:
+		return e.dwarfData.Type(entry.Offset)
+	}
+
+	// Case 2: The entry refers to a type (e.g., TagMember, TagVariable).
+	// We use its AttrType field to find the offset of the type definition.
+	typeOffset, ok := entry.Val(dwarf.AttrType).(dwarf.Offset)
+	if !ok {
+		return nil, fmt.Errorf("entry (Tag: %s) has no AttrType field", entry.Tag)
+	}
+
+	return e.dwarfData.Type(typeOffset)
+}
+
+// extractStructs extracts input structure metadata from discovered KFuzzTest
+// targets (funcs).
+// Performs a tree-traversal as all struct types need to be defined in the
+// resulting description that is emitted by the builder.
+func (e *Extractor) extractStructs(funcs []SyzFunc) ([]SyzStruct, error) {
+	// Set of input map names so that we can skip over entries that aren't
+	// interesting.
+	inputStructs := make(map[string]bool)
+	for _, fn := range funcs {
+		inputStructs[fn.InputStructName] = true
+	}
+	// Unpacks nested types to find an underlying struct type, or return nil
+	// if nothing is found. For example, when called on `struct myStruct **`
+	// we return `struct myStruct`.
+	unpackNested := func(t dwarf.Type) *dwarf.StructType {
+		for {
+			switch concreteType := t.(type) {
+			case *dwarf.StructType:
+				return concreteType
+			case *dwarf.PtrType:
+				t = concreteType.Type
+			case *dwarf.QualType:
+				t = concreteType.Type
+			default:
+				return nil
+			}
+		}
+	}
+
+	structs := make([]SyzStruct, 0)
+
+	// Perform a DFS on discovered struct types in order to discover nested
+	// struct types that may be contained within them.
+	visited := make(map[string]bool)
+	var visitRecur func(*dwarf.StructType)
+	visitRecur = func(start *dwarf.StructType) {
+		newStruct := SyzStruct{dwarfType: start, Name: start.StructName, Fields: make([]SyzField, 0)}
+		for _, child := range start.Field {
+			newField := SyzField{Name: child.Name, dwarfType: child.Type}
+			newStruct.Fields = append(newStruct.Fields, newField)
+			switch childType := child.Type.(type) {
+			case *dwarf.StructType:
+				if _, contains := visited[childType.StructName]; !contains {
+					visited[childType.StructName] = true
+					visitRecur(childType)
+				}
+			case *dwarf.PtrType, *dwarf.QualType:
+				// If we hit a pointer or a qualifier, we unpack to see if we
+				// find a nested struct type so that we can visit it.
+				maybeStructType := unpackNested(childType)
+				if maybeStructType != nil {
+					if _, contains := visited[maybeStructType.StructName]; !contains {
+						visited[maybeStructType.StructName] = true
+						visitRecur(maybeStructType)
+					}
+				}
+			default:
+				continue
+			}
+		}
+		structs = append(structs, newStruct)
+	}
+
+	dwarfReader := e.dwarfData.Reader()
+	for {
+		entry, err := dwarfReader.Next()
+		if err != nil {
+			return nil, err
+		}
+		// EOF.
+		if entry == nil {
+			break
+		}
+		if entry.Tag != dwarf.TagStructType {
+			continue
+		}
+		// Skip over unnamed structures.
+		nameField := entry.AttrField(dwarf.AttrName)
+		if nameField == nil {
+			continue
+		}
+		name, ok := nameField.Val.(string)
+		if !ok {
+			fmt.Printf("unable to get name field\n")
+			continue
+		}
+		// Dwarf file prefixes structures with `struct` so we must prepend
+		// before lookup.
+		structName := "struct " + name
+		// Check whether or not this type is one that we parsed previously
+		// while traversing the .kftf section of the vmlinux binary, discarding
+		// if this is not the case.
+		if _, ok := inputStructs[structName]; !ok {
+			continue
+		}
+
+		t, err := e.dwarfGetType(entry)
+		if err != nil {
+			return nil, err
+		}
+
+		switch entryType := t.(type) {
+		case *dwarf.StructType:
+			visitRecur(entryType)
+		default:
+			// We shouldn't hit this branch if everything before this is
+			// correct.
+			panic("Error parsing dwarf - well-formed?")
+		}
+	}
+
+	return structs, nil
+}
+
+// Parses a slice of kftf objects contained within a dedicated section. This
+// function assumes that all entries are tightly packed, and that each section
+// contains only one type of statically-sized entry types.
+func parseKftfObjects[T interface {
+	*P
+	parsableFromBytes
+}, P any](e *Extractor) ([]T, error) {
+	var typeinfo T
+
+	startSymbol, err := e.getSymbol(typeinfo.startSymbol())
+	if err != nil {
+		return nil, err
+	} else if startSymbol.Value == 0 {
+		return nil, fmt.Errorf("failed to resolve %s", typeinfo.startSymbol())
+	}
+
+	endSymbol, err := e.getSymbol(typeinfo.endSymbol())
+	if err != nil {
+		return nil, err
+	} else if endSymbol.Value == 0 {
+		return nil, fmt.Errorf("failed to resolve %s", typeinfo.endSymbol())
+	}
+
+	out := make([]T, 0)
+	data := make([]byte, typeinfo.size())
+	for addr := startSymbol.Value; addr < endSymbol.Value; addr += typeinfo.size() {
+		section := e.elfSection(addr)
+		if section == nil {
+			return nil, fmt.Errorf("failed to locate section for addr=0x%x", addr)
+		}
+
+		n, err := section.ReadAt(data, int64(addr-section.Addr))
+		if err != nil || n < int(typeinfo.size()) {
+			// If n < sizeof(T), then err is non-nil as per the documentation
+			// of section.ReadAt.
+			return nil, err
+		}
+
+		obj := T(new(P))
+		err = obj.fromBytes(e.elfFile, data)
+		if err != nil {
+			return nil, err
+		}
+		out = append(out, obj)
+	}
+
+	return out, nil
+}
diff --git a/pkg/kfuzztest/kfuzztest.go b/pkg/kfuzztest/kfuzztest.go
new file mode 100644
index 000000000..c4702ac42
--- /dev/null
+++ b/pkg/kfuzztest/kfuzztest.go
@@ -0,0 +1,207 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+// Package kfuzztest exposes functions discovering KFuzzTest test cases from a
+// vmlinux binary and parsing them into syzkaller-compatible formats.
+// The general flow includes:
+//   - Creating an Extractor that extracts these test cases from the binary
+//   - Creating a Builder that takes the extractor's output and returns some
+//     compatible encoding of the test cases that were discovered
+package kfuzztest
+
+import (
+	"debug/dwarf"
+	"fmt"
+	"path"
+	"strings"
+	"sync"
+
+	"github.com/google/syzkaller/pkg/ast"
+	"github.com/google/syzkaller/pkg/compiler"
+	"github.com/google/syzkaller/prog"
+	"github.com/google/syzkaller/sys/targets"
+)
+
+type SyzField struct {
+	Name      string
+	dwarfType dwarf.Type
+}
+
+type SyzStruct struct {
+	dwarfType *dwarf.StructType
+	Name      string
+	Fields    []SyzField
+}
+
+type SyzFunc struct {
+	Name            string
+	InputStructName string
+}
+
+type ConstraintType uint8
+
+const (
+	ExpectEq ConstraintType = iota
+	ExpectNe
+	ExpectLt
+	ExpectLe
+	ExpectGt
+	ExpectGe
+	ExpectInRange
+)
+
+func (c ConstraintType) String() string {
+	return [...]string{"EXPECT_EQ", "EXPECT_NE", "EXPECT_LT", "EXPECT_LE", "EXPECT_GT", "EXPECT_GE", "EXPECT_IN_RANGE"}[c]
+}
+
+type SyzConstraint struct {
+	InputType string
+	FieldName string
+	Value1    uintptr
+	Value2    uintptr
+	ConstraintType
+}
+
+type AnnotationAttribute uint8
+
+const (
+	AttributeLen AnnotationAttribute = iota
+	AttributeString
+	AttributeArray
+)
+
+func (a AnnotationAttribute) String() string {
+	return [...]string{"ATTRIBUTE_LEN", "ATTRIBUTE_STRING", "ATTRIBUTE_ARRAY"}[a]
+}
+
+type SyzAnnotation struct {
+	InputType       string
+	FieldName       string
+	LinkedFieldName string
+	Attribute       AnnotationAttribute
+}
+
+// ExtractDescription returns a syzlang description of all discovered KFuzzTest
+// targets, or an error on failure.
+func ExtractDescription(vmlinuxPath string) (string, error) {
+	extractor, err := NewExtractor(vmlinuxPath)
+	if err != nil {
+		return "", err
+	}
+	defer extractor.Close()
+	eRes, err := extractor.ExtractAll()
+	if err != nil {
+		return "", err
+	}
+	builder := NewBuilder(eRes.Funcs, eRes.Structs, eRes.Constraints, eRes.Annotations)
+	return builder.EmitSyzlangDescription()
+}
+
+type KFuzzTestData struct {
+	Description string
+	Calls       []*prog.Syscall
+	Resources   []*prog.ResourceDesc
+	Types       []prog.Type
+}
+
+func extractData(vmlinuxPath string) (KFuzzTestData, error) {
+	desc, err := ExtractDescription(vmlinuxPath)
+	if err != nil {
+		return KFuzzTestData{}, err
+	}
+
+	var astError error
+	eh := func(pos ast.Pos, msg string) {
+		astError = fmt.Errorf("ast error: %v: %v", pos, msg)
+	}
+	descAst := ast.Parse([]byte(desc), "kfuzztest-autogen", eh)
+	if astError != nil {
+		return KFuzzTestData{}, astError
+	}
+	if descAst == nil {
+		return KFuzzTestData{}, fmt.Errorf("failed to build AST for program")
+	}
+
+	// TODO: this assumes x86_64, but KFuzzTest supports (in theory) any
+	// architecture.
+	target := targets.Get(targets.Linux, targets.AMD64)
+	program := compiler.Compile(descAst, make(map[string]uint64), target, eh)
+	if astError != nil {
+		return KFuzzTestData{}, fmt.Errorf("failed to compile extracted KFuzzTest target: %w", astError)
+	}
+
+	kFuzzTestCalls := []*prog.Syscall{}
+	for _, call := range program.Syscalls {
+		// The generated descriptions contain some number of built-ins, which
+		// we want to filter out.
+		if call.Attrs.KFuzzTest {
+			kFuzzTestCalls = append(kFuzzTestCalls, call)
+		}
+	}
+
+	// We restore links on all generated system calls for completeness, but we
+	// only return the filtered slice.
+	prog.RestoreLinks(program.Syscalls, program.Resources, program.Types)
+
+	return KFuzzTestData{
+		Description: desc,
+		Calls:       kFuzzTestCalls,
+		Resources:   program.Resources,
+		Types:       program.Types,
+	}, nil
+}
+
+type extractKFuzzTestDataState struct {
+	once sync.Once
+	data KFuzzTestData
+	err  error
+}
+
+var extractState extractKFuzzTestDataState
+
+// ExtractData extracts KFuzzTest data from a vmlinux binary. The return value
+// of this call is cached so that it can be safely called multiple times
+// without incurring a new scan of a vmlinux image.
+// NOTE: the implementation assumes the existence of only one vmlinux image
+// per process, i.e. no attempt is made to distinguish different vmlinux images
+// based on their path.
+func ExtractData(vmlinuxPath string) (KFuzzTestData, error) {
+	extractState.once.Do(func() {
+		extractState.data, extractState.err = extractData(vmlinuxPath)
+	})
+
+	return extractState.data, extractState.err
+}
+
+// ActivateKFuzzTargets extracts all KFuzzTest targets from a vmlinux binary
+// and extends a target with the discovered pseudo-syscalls.
+func ActivateKFuzzTargets(target *prog.Target, vmlinuxPath string) ([]*prog.Syscall, error) {
+	data, err := ExtractData(vmlinuxPath)
+	if err != nil {
+		return nil, err
+	}
+	// TODO: comment this properly. It's important to note here that despite
+	// extending the target, correct encoding relies on syz_kfuzztest_run being
+	// compiled into the target, and its ID being available.
+	target.Extend(data.Calls, data.Types, data.Resources)
+	return data.Calls, nil
+}
+
+const syzKfuzzTestRun string = "syz_kfuzztest_run"
+
+// Common prefix that all discriminated syz_kfuzztest_run pseudo-syscalls share.
+const KfuzzTestTargetPrefix string = syzKfuzzTestRun + "$"
+
+func GetTestName(syscall *prog.Syscall) (string, bool) {
+	if syscall.CallName != syzKfuzzTestRun {
+		return "", false
+	}
+	return strings.CutPrefix(syscall.Name, KfuzzTestTargetPrefix)
+}
+
+const kFuzzTestDir string = "/sys/kernel/debug/kfuzztest"
+const inputFile string = "input"
+
+func GetInputFilepath(testName string) string {
+	return path.Join(kFuzzTestDir, testName, inputFile)
+}
diff --git a/pkg/kfuzztest/testdata/.gitignore b/pkg/kfuzztest/testdata/.gitignore
new file mode 100644
index 000000000..837170fcd
--- /dev/null
+++ b/pkg/kfuzztest/testdata/.gitignore
@@ -0,0 +1 @@
+*bin
diff --git a/pkg/kfuzztest/testdata/1/desc.txt b/pkg/kfuzztest/testdata/1/desc.txt
new file mode 100644
index 000000000..6d18ebeea
--- /dev/null
+++ b/pkg/kfuzztest/testdata/1/desc.txt
@@ -0,0 +1,7 @@
+# This description was automatically generated with tools/kfuzztest-gen
+pkcs7_parse_message_arg {
+	data	ptr[in, array[int8]]
+	datalen	len[data, int64]
+}
+
+syz_kfuzztest_run$test_pkcs7_parse_message(name ptr[in, string["test_pkcs7_parse_message"]], data ptr[in, pkcs7_parse_message_arg], len bytesize[data], buf ptr[in, array[int8, 65536]]) (kfuzz_test)
diff --git a/pkg/kfuzztest/testdata/1/prog.c b/pkg/kfuzztest/testdata/1/prog.c
new file mode 100644
index 000000000..b1940ba1f
--- /dev/null
+++ b/pkg/kfuzztest/testdata/1/prog.c
@@ -0,0 +1,24 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+#include "../common.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+struct pkcs7_parse_message_arg {
+	const void* data;
+	size_t datalen;
+};
+
+DEFINE_FUZZ_TARGET(test_pkcs7_parse_message, struct pkcs7_parse_message_arg);
+/* Expect data != NULL. */
+DEFINE_CONSTRAINT(pkcs7_parse_message_arg, data, NULL, NULL, EXPECT_NE);
+/* Expect datalen == len(data). */
+DEFINE_ANNOTATION(pkcs7_parse_message_arg, datalen, data, ATTRIBUTE_LEN);
+/* Annotate data as an array. */
+DEFINE_ANNOTATION(pkcs7_parse_message_arg, data, , ATTRIBUTE_ARRAY);
+
+/* Define a main function, otherwise the compiler complains. */
+int main(void)
+{
+}
diff --git a/pkg/kfuzztest/testdata/2/desc.txt b/pkg/kfuzztest/testdata/2/desc.txt
new file mode 100644
index 000000000..55ee03f8f
--- /dev/null
+++ b/pkg/kfuzztest/testdata/2/desc.txt
@@ -0,0 +1,15 @@
+# This description was automatically generated with tools/kfuzztest-gen
+bar {
+	a	int32
+	b	int32
+}
+
+foo {
+	b	ptr[in, bar]
+	str	ptr[in, string]
+	data	ptr[in, array[int8]]
+	datalen	len[data, int64]
+	numbers	ptr[in, array[int64]]
+}
+
+syz_kfuzztest_run$some_target(name ptr[in, string["some_target"]], data ptr[in, foo], len bytesize[data], buf ptr[in, array[int8, 65536]]) (kfuzz_test)
diff --git a/pkg/kfuzztest/testdata/2/prog.c b/pkg/kfuzztest/testdata/2/prog.c
new file mode 100644
index 000000000..908ccd271
--- /dev/null
+++ b/pkg/kfuzztest/testdata/2/prog.c
@@ -0,0 +1,39 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+#include "../common.h"
+
+#include <stdlib.h>
+
+struct bar {
+	int a;
+	int b;
+};
+
+struct foo {
+	struct bar* b;
+	const char* str;
+	const char* data;
+	size_t datalen;
+	uint64_t* numbers;
+};
+
+DEFINE_FUZZ_TARGET(some_target, struct foo);
+/* Expect foo.bar != NULL. */
+DEFINE_CONSTRAINT(foo, bar, NULL, NULL, EXPECT_NE);
+/* Expect foo.str != NULL. */
+DEFINE_CONSTRAINT(foo, str, NULL, NULL, EXPECT_NE);
+/* Annotate foo.str as a string. */
+DEFINE_ANNOTATION(foo, str, , ATTRIBUTE_STRING);
+/* Expect foo.data != NULL. */
+DEFINE_CONSTRAINT(foo, data, NULL, NULL, EXPECT_NE);
+/* Annotate foo.data as an array. */
+DEFINE_ANNOTATION(foo, data, , ATTRIBUTE_ARRAY);
+/* Annotate foo.datalen == len(foo.data). */
+DEFINE_ANNOTATION(foo, datalen, data, ATTRIBUTE_LEN);
+/* Annotate foo.numbers as an array. */
+DEFINE_ANNOTATION(foo, numbers, , ATTRIBUTE_ARRAY);
+
+/* Define a main function, otherwise the compiler complains. */
+int main(void)
+{
+}
diff --git a/pkg/kfuzztest/testdata/common.h b/pkg/kfuzztest/testdata/common.h
new file mode 100644
index 000000000..29e8b193e
--- /dev/null
+++ b/pkg/kfuzztest/testdata/common.h
@@ -0,0 +1,81 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+// Common struct definitions that ressemble those sound in the kernel source
+// under include/linux/kfuzztest.h. For testing purposes, it is only required
+// that these have the same sizes and emitted metadata as the kernel
+// definitions, and therefore there is no strict requirement that their fields
+// match one-to-one.
+#ifndef COMMON_H
+#define COMMON_H
+
+#include <stdint.h>
+
+struct kfuzztest_target {
+	const char *name;
+	const char *arg_type_name;
+	uintptr_t write_input_cb;
+} __attribute__((aligned(32)));
+
+enum kfuzztest_constraint_type {
+	EXPECT_EQ,
+	EXPECT_NE,
+	EXPECT_LT,
+	EXPECT_LE,
+	EXPECT_GT,
+	EXPECT_GE,
+	EXPECT_IN_RANGE,
+};
+
+struct kfuzztest_constraint {
+	const char *input_type;
+	const char *field_name;
+	uintptr_t value1;
+	uintptr_t value2;
+	enum kfuzztest_constraint_type type;
+} __attribute__((aligned(64)));
+
+enum kfuzztest_annotation_attribute {
+	ATTRIBUTE_LEN,
+	ATTRIBUTE_STRING,
+	ATTRIBUTE_ARRAY,
+};
+
+struct kfuzztest_annotation {
+	const char *input_type;
+	const char *field_name;
+	const char *linked_field_name;
+	enum kfuzztest_annotation_attribute attrib;
+} __attribute__((aligned(32)));
+
+#define DEFINE_FUZZ_TARGET(test_name, test_arg_type)                        \
+	struct kfuzztest_target __fuzz_test__##test_name                    \
+		__attribute__((section(".kfuzztest_target"), __used__)) = { \
+			.name = #test_name,                                 \
+			.arg_type_name = #test_arg_type,                    \
+		};                                                          \
+	/* Avoid the compiler optimizing out the struct definition. */      \
+	static test_arg_type arg;
+
+#define DEFINE_CONSTRAINT(arg_type, field, val1, val2, tpe)                  \
+	static struct kfuzztest_constraint __constraint_##arg_type##_##field \
+		__attribute__((section(".kfuzztest_constraint"),             \
+			       __used__)) = {                                \
+			.input_type = "struct " #arg_type,                   \
+			.field_name = #field,                                \
+			.value1 = (uintptr_t)val1,                           \
+			.value2 = (uintptr_t)val2,                           \
+			.type = tpe,                                         \
+		}
+
+#define DEFINE_ANNOTATION(arg_type, field, linked_field, attribute)          \
+	static struct kfuzztest_annotation __annotation_##arg_type##_##field \
+		__attribute__((section(".kfuzztest_annotation"),             \
+			       __used__)) = {                                \
+			.input_type = "struct " #arg_type,                   \
+			.field_name = #field,                                \
+			.linked_field_name = #linked_field,                  \
+			.attrib = attribute,                                 \
+		}
+
+#endif /* COMMON_H */
diff --git a/pkg/kfuzztest/testdata/linker.ld b/pkg/kfuzztest/testdata/linker.ld
new file mode 100644
index 000000000..345c02128
--- /dev/null
+++ b/pkg/kfuzztest/testdata/linker.ld
@@ -0,0 +1,39 @@
+/* Copyright 2025 syzkaller project authors. All rights reserved. */
+/* Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file. */
+
+/* Defines a basic linkage script for building kernel-like KFuzzTest metadata into a binary. */
+PAGE_SIZE = 0x1000;
+
+PHDRS
+{
+    text PT_LOAD FLAGS(5); /* R, X */
+    data PT_LOAD FLAGS(6); /* R, W */
+}
+
+SECTIONS
+{
+    .text : { *(.text) } :text
+
+    .rodata : {
+        *(.rodata*)
+
+        . = ALIGN(PAGE_SIZE);
+        __kfuzztest_targets_start = .;
+        KEEP(*(.kfuzztest_target));
+        __kfuzztest_targets_end = .;
+
+        . = ALIGN(PAGE_SIZE);
+        __kfuzztest_constraints_start = .;
+        KEEP(*(.kfuzztest_constraint));
+        __kfuzztest_constraints_end = .;
+
+        . = ALIGN(PAGE_SIZE);
+        __kfuzztest_annotations_start = .;
+        KEEP(*(.kfuzztest_annotation));
+        __kfuzztest_annotations_end = .;
+
+    } :text
+
+    .data : { *(.data) } :data
+    .bss : { *(.bss) } :data
+}
diff --git a/pkg/kfuzztest/types.go b/pkg/kfuzztest/types.go
new file mode 100644
index 000000000..b533f95c3
--- /dev/null
+++ b/pkg/kfuzztest/types.go
@@ -0,0 +1,135 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package kfuzztest
+
+import (
+	"debug/elf"
+	"fmt"
+)
+
+// The parsableFromBytes interface describes a kftf object that can be parsed
+// from a vmlinux binary. All objects are expected to satisfy the following
+// constraints
+//   - Must be statically sized. I.e. the size() function should return some
+//     fixed value
+//   - Densely packed: size must exactly describe the number of bytes between
+//     the start address of instance i and that of instance i+1.
+//
+// No further assumptions are made about the semantics of the object. For
+// example if some field is a pointer to a string (*const char) this will not
+// be read from the binary. This responsibility is offloaded to the caller.
+type parsableFromBytes interface {
+	fromBytes(elfFile *elf.File, data []byte) error
+	size() uint64
+	startSymbol() string
+	endSymbol() string
+}
+
+type kfuzztestTarget struct {
+	name    uint64
+	argType uint64
+	writeCb uint64
+	readCb  uint64
+}
+
+const kfuzztestTargetStart string = "__kfuzztest_targets_start"
+const kfuzztestTargetEnd string = "__kfuzztest_targets_end"
+const kfuzztestTargetSize uint64 = 32
+
+func incorrectByteSizeErr(expected, actual uint64) error {
+	return fmt.Errorf("incorrect number of bytes: expected %d, got %d", expected, actual)
+}
+
+func (targ *kfuzztestTarget) fromBytes(elfFile *elf.File, data []byte) error {
+	if targ.size() != uint64(len(data)) {
+		return incorrectByteSizeErr(targ.size(), uint64(len(data)))
+	}
+	targ.name = elfFile.ByteOrder.Uint64(data[0:8])
+	targ.argType = elfFile.ByteOrder.Uint64(data[8:16])
+	targ.writeCb = elfFile.ByteOrder.Uint64(data[16:24])
+	targ.readCb = elfFile.ByteOrder.Uint64(data[24:32])
+	return nil
+}
+
+func (targ *kfuzztestTarget) size() uint64 {
+	return kfuzztestTargetSize
+}
+
+func (targ *kfuzztestTarget) startSymbol() string {
+	return kfuzztestTargetStart
+}
+
+func (targ *kfuzztestTarget) endSymbol() string {
+	return kfuzztestTargetEnd
+}
+
+type kfuzztestConstraint struct {
+	inputType      uint64
+	fieldName      uint64
+	value1         uintptr
+	value2         uintptr
+	constraintType uint8
+}
+
+const kfuzztestConstraintStart string = "__kfuzztest_constraints_start"
+const kfuzztestConstraintEnd string = "__kfuzztest_constraints_end"
+const kfuzztestConstraintSize uint64 = 64
+
+func (c *kfuzztestConstraint) fromBytes(elfFile *elf.File, data []byte) error {
+	if c.size() != uint64(len(data)) {
+		return incorrectByteSizeErr(c.size(), uint64(len(data)))
+	}
+	constraintTypeBytes := elfFile.ByteOrder.Uint64(data[32:40])
+	c.inputType = elfFile.ByteOrder.Uint64(data[0:8])
+	c.fieldName = elfFile.ByteOrder.Uint64(data[8:16])
+	c.value1 = uintptr(elfFile.ByteOrder.Uint64(data[16:24]))
+	c.value2 = uintptr(elfFile.ByteOrder.Uint64(data[24:32]))
+	c.constraintType = uint8(constraintTypeBytes & 0xFF)
+	return nil
+}
+
+func (c *kfuzztestConstraint) size() uint64 {
+	return kfuzztestConstraintSize
+}
+
+func (c *kfuzztestConstraint) startSymbol() string {
+	return kfuzztestConstraintStart
+}
+
+func (c *kfuzztestConstraint) endSymbol() string {
+	return kfuzztestConstraintEnd
+}
+
+type kfuzztestAnnotation struct {
+	inputType           uint64
+	fieldName           uint64
+	linkedFieldName     uint64
+	annotationAttribute uint8
+}
+
+func (a *kfuzztestAnnotation) fromBytes(elfFile *elf.File, data []byte) error {
+	if a.size() != uint64(len(data)) {
+		return incorrectByteSizeErr(a.size(), uint64(len(data)))
+	}
+	a.inputType = elfFile.ByteOrder.Uint64(data[0:8])
+	a.fieldName = elfFile.ByteOrder.Uint64(data[8:16])
+	a.linkedFieldName = elfFile.ByteOrder.Uint64(data[16:24])
+	a.annotationAttribute = data[24]
+	return nil
+}
+
+const kftfAnnotationStart string = "__kfuzztest_annotations_start"
+const kftfAnnotationEnd string = "__kfuzztest_annotations_end"
+const kftfAnnotationSize uint64 = 32
+
+func (a *kfuzztestAnnotation) size() uint64 {
+	return kftfAnnotationSize
+}
+
+func (a *kfuzztestAnnotation) startSymbol() string {
+	return kftfAnnotationStart
+}
+
+func (a *kfuzztestAnnotation) endSymbol() string {
+	return kftfAnnotationEnd
+}
diff --git a/pkg/mgrconfig/config.go b/pkg/mgrconfig/config.go
index c9944900e..45145243c 100644
--- a/pkg/mgrconfig/config.go
+++ b/pkg/mgrconfig/config.go
@@ -255,6 +255,9 @@ type Experimental struct {
 	// with an empty Filter, but non-empty weight.
 	// E.g. "focus_areas": [ {"filter": {"files": ["^net"]}, "weight": 10.0}, {"weight": 1.0} ].
 	FocusAreas []FocusArea `json:"focus_areas,omitempty"`
+
+	// Enable dynamic discovery and fuzzing of KFuzzTest targets.
+	EnableKFuzzTest bool `json:"enable_kfuzztest"`
 }
 
 type FocusArea struct {
diff --git a/pkg/runtest/run.go b/pkg/runtest/run.go
index 36159b9a7..ffd791c68 100644
--- a/pkg/runtest/run.go
+++ b/pkg/runtest/run.go
@@ -32,6 +32,13 @@ import (
 	"github.com/google/syzkaller/sys/targets"
 )
 
+// Pseudo-syscalls that might not provide any coverage when invoked.
+var noCovSyscalls = map[string]struct{}{
+	"syz_btf_id_by_name":            {},
+	"syz_kvm_assert_syzos_uexit":    {},
+	"syz_kvm_assert_syzos_kvm_exit": {},
+}
+
 type runRequest struct {
 	*queue.Request
 	sourceOpts *csource.Options
@@ -520,17 +527,24 @@ func checkResult(req *runRequest) error {
 func checkCallResult(req *runRequest, isC bool, run, call int, info *flatrpc.ProgInfo, calls map[string]bool) error {
 	inf := info.Calls[call]
 	want := req.results.Calls[call]
+	if err := checkCallStatus(req, isC, run, call, inf, want); err != nil {
+		return err
+	}
+	if isC || inf.Flags&flatrpc.CallFlagExecuted == 0 {
+		return nil
+	}
+	// We check coverage only for syz-executor.
+	return checkCallCoverage(req, run, call, info, calls)
+}
+
+func checkCallStatus(req *runRequest, isC bool, run, call int, inf, want *flatrpc.CallInfo) error {
+	// In non-threaded mode blocked syscalls will block the main thread
+	// and we won't detect blocked/unfinished syscalls.
+	// C code also does not detect blocked/non-finished calls.
+	ignoreFlags := isC || req.ExecOpts.ExecFlags&flatrpc.ExecFlagThreaded == 0
 	for flag, what := range flatrpc.EnumNamesCallFlag {
-		if flag != flatrpc.CallFlagFinished {
-			if isC {
-				// C code does not detect blocked/non-finished calls.
-				continue
-			}
-			if req.ExecOpts.ExecFlags&flatrpc.ExecFlagThreaded == 0 {
-				// In non-threaded mode blocked syscalls will block main thread
-				// and we won't detect blocked/unfinished syscalls.
-				continue
-			}
+		if ignoreFlags && flag != flatrpc.CallFlagFinished {
+			continue
 		}
 		if runtime.GOOS == targets.FreeBSD && flag == flatrpc.CallFlagBlocked {
 			// Blocking detection is flaky on freebsd.
@@ -538,49 +552,47 @@ func checkCallResult(req *runRequest, isC bool, run, call int, info *flatrpc.Pro
 			continue
 		}
 		if (inf.Flags^want.Flags)&flag != 0 {
-			not := " not"
-			if inf.Flags&flag != 0 {
-				not = ""
-			}
-			return fmt.Errorf("run %v: call %v is%v %v", run, call, not, what)
+			return fmt.Errorf("run %v: call %v %v %v, want %v",
+				run, call, flagStatus(inf.Flags, flag), what, flagStatus(want.Flags, flag))
 		}
 	}
 	if inf.Flags&flatrpc.CallFlagFinished != 0 && inf.Error != want.Error {
 		return fmt.Errorf("run %v: wrong call %v result %v, want %v",
 			run, call, inf.Error, want.Error)
 	}
-	if isC || inf.Flags&flatrpc.CallFlagExecuted == 0 {
-		return nil
+	return nil
+}
+
+func flagStatus(flags, flag flatrpc.CallFlag) string {
+	if flags&flag != 0 {
+		return "is"
 	}
-	if req.ExecOpts.EnvFlags&flatrpc.ExecEnvSignal != 0 {
-		// Signal is always deduplicated, so we may not get any signal
-		// on a second invocation of the same syscall.
-		// For calls that are not meant to collect synchronous coverage we
-		// allow the signal to be empty as long as the extra signal is not.
-		callName := req.Prog.Calls[call].Meta.CallName
-		if len(inf.Signal) < 2 && !calls[callName] && len(info.Extra.Signal) == 0 {
-			return fmt.Errorf("run %v: call %v: no signal", run, call)
-		}
-		// Pseudo-syscalls that might not provide any coverage when invoked.
-		noCovSyscalls := []string{"syz_btf_id_by_name", "syz_kvm_assert_syzos_uexit"}
-		if len(inf.Cover) == 0 {
-			found := true
-			for _, s := range noCovSyscalls {
-				if callName == s {
-					found = true
-					break
-				}
-			}
-			if !found {
-				return fmt.Errorf("run %v: call %v: no cover", run, call)
-			}
-		}
-		calls[callName] = true
-	} else {
+	return "is not"
+}
+
+func checkCallCoverage(req *runRequest, run, call int, info *flatrpc.ProgInfo, calls map[string]bool) error {
+	inf := info.Calls[call]
+	if req.ExecOpts.EnvFlags&flatrpc.ExecEnvSignal == 0 {
 		if len(inf.Signal) != 0 {
 			return fmt.Errorf("run %v: call %v: got %v unwanted signal", run, call, len(inf.Signal))
 		}
+		return nil
+	}
+	callName := req.Prog.Calls[call].Meta.CallName
+	_, isNoCov := noCovSyscalls[callName]
+	// Signal is always deduplicated, so we may not get any signal
+	// on a second invocation of the same syscall.
+	// For calls that are not meant to collect synchronous coverage we
+	// allow the signal to be empty as long as the extra signal is not.
+	if !isNoCov && !calls[callName] {
+		if len(inf.Signal) < 2 && len(info.Extra.Signal) == 0 {
+			return fmt.Errorf("run %v: call %v: no signal", run, call)
+		}
+	}
+	if !isNoCov && len(inf.Cover) == 0 {
+		return fmt.Errorf("run %v: call %v: no cover", run, call)
 	}
+	calls[callName] = true
 	return nil
 }
 
diff --git a/pkg/vminfo/linux_syscalls.go b/pkg/vminfo/linux_syscalls.go
index c5d1cf405..605b939d2 100644
--- a/pkg/vminfo/linux_syscalls.go
+++ b/pkg/vminfo/linux_syscalls.go
@@ -62,49 +62,51 @@ func linuxSupportedLSM(ctx *checkContext, call *prog.Syscall) string {
 }
 
 var linuxSyscallChecks = map[string]func(*checkContext, *prog.Syscall) string{
-	"openat":                      supportedOpenat,
-	"mount":                       linuxSupportedMount,
-	"socket":                      linuxSupportedSocket,
-	"socketpair":                  linuxSupportedSocket,
-	"pkey_alloc":                  linuxPkeysSupported,
-	"syz_open_dev":                linuxSyzOpenDevSupported,
-	"syz_open_procfs":             linuxSyzOpenProcfsSupported,
-	"syz_open_pts":                alwaysSupported,
-	"syz_execute_func":            alwaysSupported,
-	"syz_emit_ethernet":           linuxNetInjectionSupported,
-	"syz_extract_tcp_res":         linuxNetInjectionSupported,
-	"syz_usb_connect":             linuxCheckUSBEmulation,
-	"syz_usb_connect_ath9k":       linuxCheckUSBEmulation,
-	"syz_usb_disconnect":          linuxCheckUSBEmulation,
-	"syz_usb_control_io":          linuxCheckUSBEmulation,
-	"syz_usb_ep_write":            linuxCheckUSBEmulation,
-	"syz_usb_ep_read":             linuxCheckUSBEmulation,
-	"syz_kvm_setup_cpu":           linuxSyzKvmSupported,
-	"syz_kvm_vgic_v3_setup":       linuxSyzSupportedOnArm64,
-	"syz_kvm_setup_syzos_vm":      linuxSyzKvmSupported,
-	"syz_kvm_add_vcpu":            linuxSyzKvmSupported,
-	"syz_kvm_assert_syzos_uexit":  linuxSyzKvmSupported,
-	"syz_kvm_assert_reg":          linuxSyzSupportedOnArm64,
-	"syz_emit_vhci":               linuxVhciInjectionSupported,
-	"syz_init_net_socket":         linuxSyzInitNetSocketSupported,
-	"syz_genetlink_get_family_id": linuxSyzGenetlinkGetFamilyIDSupported,
-	"syz_mount_image":             linuxSyzMountImageSupported,
-	"syz_read_part_table":         linuxSyzReadPartTableSupported,
-	"syz_io_uring_setup":          alwaysSupported,
-	"syz_io_uring_submit":         alwaysSupported,
-	"syz_io_uring_complete":       alwaysSupported,
-	"syz_memcpy_off":              alwaysSupported,
-	"syz_btf_id_by_name":          linuxBtfVmlinuxSupported,
-	"syz_fuse_handle_req":         alwaysSupported,
-	"syz_80211_inject_frame":      linuxWifiEmulationSupported,
-	"syz_80211_join_ibss":         linuxWifiEmulationSupported,
-	"syz_usbip_server_init":       linuxSyzUsbIPSupported,
-	"syz_clone":                   alwaysSupported,
-	"syz_clone3":                  alwaysSupported,
-	"syz_pkey_set":                linuxPkeysSupported,
-	"syz_socket_connect_nvme_tcp": linuxSyzSocketConnectNvmeTCPSupported,
-	"syz_pidfd_open":              alwaysSupported,
-	"syz_create_resource":         alwaysSupported,
+	"openat":                        supportedOpenat,
+	"mount":                         linuxSupportedMount,
+	"socket":                        linuxSupportedSocket,
+	"socketpair":                    linuxSupportedSocket,
+	"pkey_alloc":                    linuxPkeysSupported,
+	"syz_open_dev":                  linuxSyzOpenDevSupported,
+	"syz_open_procfs":               linuxSyzOpenProcfsSupported,
+	"syz_open_pts":                  alwaysSupported,
+	"syz_execute_func":              alwaysSupported,
+	"syz_emit_ethernet":             linuxNetInjectionSupported,
+	"syz_extract_tcp_res":           linuxNetInjectionSupported,
+	"syz_usb_connect":               linuxCheckUSBEmulation,
+	"syz_usb_connect_ath9k":         linuxCheckUSBEmulation,
+	"syz_usb_disconnect":            linuxCheckUSBEmulation,
+	"syz_usb_control_io":            linuxCheckUSBEmulation,
+	"syz_usb_ep_write":              linuxCheckUSBEmulation,
+	"syz_usb_ep_read":               linuxCheckUSBEmulation,
+	"syz_kvm_setup_cpu":             linuxSyzKvmSupported,
+	"syz_kvm_vgic_v3_setup":         linuxSyzSupportedOnArm64,
+	"syz_kvm_setup_syzos_vm":        linuxSyzKvmSupported,
+	"syz_kvm_add_vcpu":              linuxSyzKvmSupported,
+	"syz_kvm_assert_syzos_uexit":    linuxSyzKvmSupported,
+	"syz_kvm_assert_syzos_kvm_exit": linuxSyzKvmSupported,
+	"syz_kvm_assert_reg":            linuxSyzSupportedOnArm64,
+	"syz_emit_vhci":                 linuxVhciInjectionSupported,
+	"syz_init_net_socket":           linuxSyzInitNetSocketSupported,
+	"syz_genetlink_get_family_id":   linuxSyzGenetlinkGetFamilyIDSupported,
+	"syz_mount_image":               linuxSyzMountImageSupported,
+	"syz_read_part_table":           linuxSyzReadPartTableSupported,
+	"syz_io_uring_setup":            alwaysSupported,
+	"syz_io_uring_submit":           alwaysSupported,
+	"syz_io_uring_complete":         alwaysSupported,
+	"syz_memcpy_off":                alwaysSupported,
+	"syz_btf_id_by_name":            linuxBtfVmlinuxSupported,
+	"syz_fuse_handle_req":           alwaysSupported,
+	"syz_80211_inject_frame":        linuxWifiEmulationSupported,
+	"syz_80211_join_ibss":           linuxWifiEmulationSupported,
+	"syz_usbip_server_init":         linuxSyzUsbIPSupported,
+	"syz_clone":                     alwaysSupported,
+	"syz_clone3":                    alwaysSupported,
+	"syz_pkey_set":                  linuxPkeysSupported,
+	"syz_socket_connect_nvme_tcp":   linuxSyzSocketConnectNvmeTCPSupported,
+	"syz_pidfd_open":                alwaysSupported,
+	"syz_create_resource":           alwaysSupported,
+	"syz_kfuzztest_run":             alwaysSupported,
 }
 
 func linuxSyzOpenDevSupported(ctx *checkContext, call *prog.Syscall) string {
@@ -180,12 +182,13 @@ func linuxSyzKvmSupported(ctx *checkContext, call *prog.Syscall) string {
 		if ctx.target.Arch == targets.AMD64 || ctx.target.Arch == targets.I386 {
 			return ""
 		}
-	case "syz_kvm_setup_syzos_vm$x86", "syz_kvm_add_vcpu$x86", "syz_kvm_assert_syzos_uexit$x86":
+	case "syz_kvm_setup_syzos_vm$x86", "syz_kvm_add_vcpu$x86", "syz_kvm_assert_syzos_uexit$x86",
+		"syz_kvm_assert_syzos_kvm_exit$x86":
 		if ctx.target.Arch == targets.AMD64 {
 			return ""
 		}
 	case "syz_kvm_setup_cpu$arm64", "syz_kvm_setup_syzos_vm$arm64", "syz_kvm_add_vcpu$arm64",
-		"syz_kvm_assert_syzos_uexit$arm64":
+		"syz_kvm_assert_syzos_uexit$arm64", "syz_kvm_assert_syzos_kvm_exit$arm64":
 		if ctx.target.Arch == targets.ARM64 {
 			return ""
 		}
diff --git a/prog/encodingexec.go b/prog/encodingexec.go
index fb8e5fbaf..14466a272 100644
--- a/prog/encodingexec.go
+++ b/prog/encodingexec.go
@@ -75,7 +75,9 @@ func (p *Prog) SerializeForExec() ([]byte, error) {
 	w.write(uint64(len(p.Calls)))
 	for _, c := range p.Calls {
 		w.csumMap, w.csumUses = calcChecksumsCall(c)
-		w.serializeCall(c)
+		// TODO: if we propagate this error, something breaks and no coverage
+		// is displayed to the dashboard or the logs.
+		_ = w.serializeCall(c)
 	}
 	w.write(execInstrEOF)
 	if len(w.buf) > ExecBufferSize {
@@ -87,7 +89,14 @@ func (p *Prog) SerializeForExec() ([]byte, error) {
 	return w.buf, nil
 }
 
-func (w *execContext) serializeCall(c *Call) {
+func (w *execContext) serializeCall(c *Call) error {
+	// We introduce special serialization logic for kfuzztest targets, which
+	// require special handling due to their use of relocation tables to copy
+	// entire blobs of data into the kenrel.
+	if c.Meta.Attrs.KFuzzTest {
+		return w.serializeKFuzzTestCall(c)
+	}
+
 	// Calculate arg offsets within structs.
 	// Generate copyin instructions that fill in data into pointer arguments.
 	w.writeCopyin(c)
@@ -117,6 +126,68 @@ func (w *execContext) serializeCall(c *Call) {
 
 	// Generate copyout instructions that persist interesting return values.
 	w.writeCopyout(c)
+	return nil
+}
+
+// KFuzzTest targets require special handling due to their use of relocation
+// tables for serializing all data (including pointed-to data) into a
+// continuous blob that can be passed into the kernel.
+func (w *execContext) serializeKFuzzTestCall(c *Call) error {
+	if !c.Meta.Attrs.KFuzzTest {
+		// This is a specialized function that shouldn't be called on anything
+		// other than an instance of a syz_kfuzztest_run$* syscall
+		panic("serializeKFuzzTestCall called on an invalid syscall")
+	}
+
+	// Generate the final syscall instruction with the update arguments.
+	kFuzzTestRunID, err := w.target.KFuzzTestRunID()
+	if err != nil {
+		panic(err)
+	}
+	// Ensures that we copy some arguments into the executor so that it doesn't
+	// receive an incomplete program on failure.
+	defer func() {
+		w.write(uint64(kFuzzTestRunID))
+		w.write(ExecNoCopyout)
+		w.write(uint64(len(c.Args)))
+		for _, arg := range c.Args {
+			w.writeArg(arg)
+		}
+	}()
+
+	// Write the initial string argument (test name) normally.
+	w.writeCopyin(&Call{Meta: c.Meta, Args: []Arg{c.Args[0]}})
+
+	// Args[1] is the second argument to syz_kfuzztest_run, which is a pointer
+	// to some struct input. This is the data that must be flattened and sent
+	// to the fuzzing driver with a relocation table.
+	dataArg := c.Args[1].(*PointerArg)
+	finalBlob := MarshallKFuzztestArg(dataArg.Res)
+	if len(finalBlob) > int(KFuzzTestMaxInputSize) {
+		return fmt.Errorf("encoded blob was too large")
+	}
+
+	// Use the buffer argument as data offset - this represents a buffer of
+	// size 64KiB - the maximum input size that the KFuzzTest module accepts.
+	bufferArg := c.Args[3].(*PointerArg)
+	if bufferArg.Res == nil {
+		return fmt.Errorf("buffer was nil")
+	}
+	blobAddress := w.target.PhysicalAddr(bufferArg) - w.target.DataOffset
+
+	// Write the entire marshalled blob as a raw byte array.
+	w.write(execInstrCopyin)
+	w.write(blobAddress)
+	w.write(execArgData)
+	w.write(uint64(len(finalBlob)))
+	w.buf = append(w.buf, finalBlob...)
+
+	// Update the value of the length arg which should now match the length of
+	// the byte array that we created. Previously, it contained the bytesize
+	// of the struct argument passed into the pseudo-syscall.
+	lenArg := c.Args[2].(*ConstArg)
+	lenArg.Val = uint64(len(finalBlob))
+	return nil
 }
 
 type execContext struct {
diff --git a/prog/kfuzztest.go b/prog/kfuzztest.go
new file mode 100644
index 000000000..dacd54885
--- /dev/null
+++ b/prog/kfuzztest.go
@@ -0,0 +1,296 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package prog
+
+import (
+	"bytes"
+	"encoding/binary"
+	"fmt"
+)
+
+const (
+	kFuzzTestRegionIDNull uint32 = ^uint32(0)
+	kFuzzTestPoisonSize   uint64 = 0x8
+
+	kFuzzTestVersion    uint32 = 0
+	kFuzzTestMagic      uint32 = 0xBFACE
+	kFuzzTestPrefixSize        = 8
+
+	// Minimum region alignment required by KFuzzTest. This is exposed by the
+	// /sys/kernel/debug/kfuzztest/_config/minalign debugfs file. This value
+	// always equals MAX(ARCH_KMALLOC_MINALIGN, KFUZZTEST_POISON_SIZE) = 8 on
+	// x86_64, so we hardcode it for now. A more robust solution would involve
+	// reading this from the debugfs entry at boot before fuzzing begins.
+	kFuzzTestMinalign uint64 = 8
+
+	// Maximum input size accepted by the KFuzzTest kernel module.
+	KFuzzTestMaxInputSize uint64 = 64 << 10
+)
+
+func kFuzzTestWritePrefix(buf *bytes.Buffer) {
+	prefix := (uint64(kFuzzTestVersion) << 32) | uint64(kFuzzTestMagic)
+	binary.Write(buf, binary.LittleEndian, prefix)
+}
+
+func isPowerOfTwo(n uint64) bool {
+	return n > 0 && (n&(n-1) == 0)
+}
+
+func roundUpPowerOfTwo(x, n uint64) uint64 {
+	if !isPowerOfTwo(n) {
+		panic("n was not a power of 2")
+	}
+	return (x + n - 1) &^ (n - 1)
+}
+
+// Pad b so that it's length is a multiple of alignment, with at least
+// minPadding bytes of padding, where alignment is a power of 2.
+func padWithAlignment(b *bytes.Buffer, alignment, minPadding uint64) {
+	var newSize uint64
+	if alignment == 0 {
+		newSize = uint64(b.Len()) + minPadding
+	} else {
+		newSize = roundUpPowerOfTwo(uint64(b.Len())+minPadding, alignment)
+	}
+
+	paddingBytes := newSize - uint64(b.Len())
+	for range paddingBytes {
+		b.WriteByte(byte(0))
+	}
+}
+
+type sliceQueue[T any] struct {
+	q []T
+}
+
+func (sq *sliceQueue[T]) push(elem T) {
+	sq.q = append(sq.q, elem)
+}
+
+func (sq *sliceQueue[T]) pop() T {
+	ret := sq.q[0]
+	sq.q = sq.q[1:]
+	return ret
+}
+
+func (sq *sliceQueue[T]) isEmpty() bool {
+	return len(sq.q) == 0
+}
+
+func newSliceQueue[T any]() *sliceQueue[T] {
+	return &sliceQueue[T]{q: make([]T, 0)}
+}
+
+type kFuzzTestRelocation struct {
+	offset    uint32
+	srcRegion Arg
+	dstRegion Arg
+}
+
+type kFuzzTestRegion struct {
+	offset uint32
+	size   uint32
+}
+
+// The following helpers and definitions follow directly from the C-struct
+// definitions in <include/linux/kfuzztest.h>.
+const kFuzzTestRegionSize = 8
+
+func kFuzzTestRegionArraySize(numRegions int) int {
+	return 4 + kFuzzTestRegionSize*numRegions
+}
+
+func kFuzzTestWriteRegion(buf *bytes.Buffer, region kFuzzTestRegion) {
+	binary.Write(buf, binary.LittleEndian, region.offset)
+	binary.Write(buf, binary.LittleEndian, region.size)
+}
+
+func kFuzzTestWriteRegionArray(buf *bytes.Buffer, regions []kFuzzTestRegion) {
+	binary.Write(buf, binary.LittleEndian, uint32(len(regions)))
+	for _, reg := range regions {
+		kFuzzTestWriteRegion(buf, reg)
+	}
+}
+
+const kFuzzTestRelocationSize = 12
+
+func kFuzzTestRelocTableSize(numRelocs int) int {
+	return 8 + kFuzzTestRelocationSize*numRelocs
+}
+
+func kFuzzTestWriteReloc(buf *bytes.Buffer, regToID *map[Arg]int, reloc kFuzzTestRelocation) {
+	binary.Write(buf, binary.LittleEndian, uint32((*regToID)[reloc.srcRegion]))
+	binary.Write(buf, binary.LittleEndian, reloc.offset)
+	if reloc.dstRegion == nil {
+		binary.Write(buf, binary.LittleEndian, kFuzzTestRegionIDNull)
+	} else {
+		binary.Write(buf, binary.LittleEndian, uint32((*regToID)[reloc.dstRegion]))
+	}
+}
+
+func kFuzzTestWriteRelocTable(buf *bytes.Buffer, regToID *map[Arg]int,
+	relocations []kFuzzTestRelocation, paddingBytes uint64) {
+	binary.Write(buf, binary.LittleEndian, uint32(len(relocations)))
+	binary.Write(buf, binary.LittleEndian, uint32(paddingBytes))
+	for _, reloc := range relocations {
+		kFuzzTestWriteReloc(buf, regToID, reloc)
+	}
+	buf.Write(make([]byte, paddingBytes))
+}
+
+const kFuzzTestPlaceHolderPtr uint64 = 0xFFFFFFFFFFFFFFFF
+
+// Expands a region, and returns a list of relocations that need to be made.
+func kFuzzTestExpandRegion(reg Arg) ([]byte, []kFuzzTestRelocation) {
+	relocations := []kFuzzTestRelocation{}
+	var encoded bytes.Buffer
+	queue := newSliceQueue[Arg]()
+	queue.push(reg)
+
+	for !queue.isEmpty() {
+		arg := queue.pop()
+		padWithAlignment(&encoded, arg.Type().Alignment(), 0)
+
+		switch a := arg.(type) {
+		case *PointerArg:
+			offset := uint32(encoded.Len())
+			binary.Write(&encoded, binary.LittleEndian, kFuzzTestPlaceHolderPtr)
+			relocations = append(relocations, kFuzzTestRelocation{offset, reg, a.Res})
+		case *GroupArg:
+			for _, inner := range a.Inner {
+				queue.push(inner)
+			}
+		case *DataArg:
+			data := a.data
+			buffer, ok := a.ArgCommon.Type().(*BufferType)
+			if !ok {
+				panic("DataArg should be a BufferType")
+			}
+			// Unlike length fields whose incorrectness can be prevented easily,
+			// it is an invasive change to prevent generation of
+			// non-null-terminated strings. Forcibly null-terminating them
+			// during encoding allows us to centralize this easily and prevent
+			// false positive buffer overflows in KFuzzTest targets.
+			if buffer.Kind == BufferString && (len(data) == 0 || data[len(data)-1] != byte(0)) {
+				data = append(data, byte(0))
+			}
+			encoded.Write(data)
+		case *ConstArg:
+			val, _ := a.Value()
+			switch a.Size() {
+			case 1:
+				binary.Write(&encoded, binary.LittleEndian, uint8(val))
+			case 2:
+				binary.Write(&encoded, binary.LittleEndian, uint16(val))
+			case 4:
+				binary.Write(&encoded, binary.LittleEndian, uint32(val))
+			case 8:
+				binary.Write(&encoded, binary.LittleEndian, val)
+			default:
+				panic(fmt.Sprintf("unsupported constant size: %d", a.Size()))
+			}
+			// TODO: handle union args.
+		default:
+			panic(fmt.Sprintf("tried to serialize unsupported type: %s", a.Type().Name()))
+		}
+	}
+
+	return encoded.Bytes(), relocations
+}
+
+// MarshallKFuzzTestArg serializes a syzkaller Arg into a flat binary format
+// understood by the KFuzzTest kernel interface (see `include/linux/kfuzztest.h`).
+//
+// The goal is to represent a tree-like structure of arguments (which may contain
+// pointers and cycles) as a single byte slice that the kernel can deserialize
+// into a set of distinct heap allocations.
+//
+// The binary format consists of three contiguous parts, in this order:
+//
+//  1. Region Array: A header describing all logical memory regions that will be
+//     allocated by the kernel. Each `relocRegion` defines a region's unique `id`,
+//     its `size`, its `alignment`, and its `start` offset within the payload.
+//     The kernel uses this table to create one distinct heap allocation per region.
+//
+//  2. Relocation Table: A header containing a list of `relocationEntry` structs.
+//     Each entry identifies the location of a pointer field within the payload
+//     (via a `regionID` and `regionOffset`) and maps it to the logical region
+//     it points to (via a `value` which holds the pointee's `regionID`).
+//     A NULL pointer is identified by the special value `kFuzzTestNilPtrVal`.
+//
+//  3. Payload: The raw, serialized data for all arguments, laid out as a single
+//     contiguous block of memory with padded regions as per the KFuzzTest input
+//     format's specification defined in `Documentation/dev-tools/kfuzztest.rst`.
+//
+// Cycles are handled by tracking visited arguments, ensuring that a region is
+// only visited and encoded once.
+//
+// For a concrete example of the final binary layout, see the test cases for this
+// function in `prog/kfuzztest_test.go`.
+func MarshallKFuzztestArg(topLevel Arg) []byte {
+	regions := []kFuzzTestRegion{}
+	allRelocations := []kFuzzTestRelocation{}
+	visitedRegions := make(map[Arg]int)
+	queue := newSliceQueue[Arg]()
+	var payload bytes.Buffer
+	queue.push(topLevel)
+	maxAlignment := uint64(8)
+
+	if topLevel == nil {
+		return []byte{}
+	}
+
+Loop:
+	for {
+		if queue.isEmpty() {
+			break Loop
+		}
+
+		reg := queue.pop()
+		if _, visited := visitedRegions[reg]; visited {
+			continue Loop
+		}
+
+		alignment := max(kFuzzTestMinalign, reg.Type().Alignment())
+		maxAlignment = max(maxAlignment, alignment)
+
+		regionData, relocations := kFuzzTestExpandRegion(reg)
+		for _, reloc := range relocations {
+			if reloc.dstRegion == nil {
+				continue
+			}
+			if _, visited := visitedRegions[reloc.dstRegion]; !visited {
+				queue.push(reloc.dstRegion)
+			}
+		}
+		allRelocations = append(allRelocations, relocations...)
+
+		padWithAlignment(&payload, alignment, 0)
+		regions = append(regions, kFuzzTestRegion{
+			offset: uint32(payload.Len()),
+			size:   uint32(len(regionData))},
+		)
+		visitedRegions[reg] = len(regions) - 1
+		payload.Write(regionData)
+		// The end of the payload should have at least kFuzzTestPoisonSize bytes
+		// of padding, and be aligned to kFuzzTestPoisonSize.
+		padWithAlignment(&payload, kFuzzTestPoisonSize, kFuzzTestPoisonSize)
+	}
+
+	headerLen := 0x8 // Two integer values - the magic value, and the version number.
+	regionArrayLen := kFuzzTestRegionArraySize(len(regions))
+	relocTableLen := kFuzzTestRelocTableSize(len(allRelocations))
+	metadataLen := headerLen + regionArrayLen + relocTableLen
+
+	// The payload needs to be aligned to max alignment to ensure that all
+	// nested structs are properly aligned, and there should be enough padding
+	// so that the region before the payload can be poisoned with a redzone.
+	paddingBytes := roundUpPowerOfTwo(uint64(metadataLen)+kFuzzTestPoisonSize, maxAlignment) - uint64(metadataLen)
+
+	var out bytes.Buffer
+	kFuzzTestWritePrefix(&out)
+	kFuzzTestWriteRegionArray(&out, regions)
+	kFuzzTestWriteRelocTable(&out, &visitedRegions, allRelocations, paddingBytes)
+	out.Write(payload.Bytes())
+	return out.Bytes()
+}
diff --git a/prog/kfuzztest_test.go b/prog/kfuzztest_test.go
new file mode 100644
index 000000000..5f1b3d9c4
--- /dev/null
+++ b/prog/kfuzztest_test.go
@@ -0,0 +1,262 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package prog
+
+import (
+	"bytes"
+	"encoding/binary"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+type testCase struct {
+	prog            string
+	extractArg      func(*Prog) Arg
+	regionArray     []any
+	relocationTable []any
+	payload         []any
+}
+
+func TestRoundUpPowerOfTwo(t *testing.T) {
+	if res := roundUpPowerOfTwo(9, 8); res != 16 {
+		t.Fatalf("expected 16, got %d", res)
+	}
+	if res := roundUpPowerOfTwo(21, 4); res != 24 {
+		t.Fatalf("expected 24, got %d", res)
+	}
+	if res := roundUpPowerOfTwo(113, 16); res != 128 {
+		t.Fatalf("expected 24, got %d", res)
+	}
+}
+
+func createBuffer(data []any) []byte {
+	var buf bytes.Buffer
+
+	for _, d := range data {
+		switch val := d.(type) {
+		case uint8, uint16, uint32, uint64:
+			binary.Write(&buf, binary.LittleEndian, val)
+		case []byte:
+			buf.Write(val)
+		}
+	}
+
+	return buf.Bytes()
+}
+
+func createPrefix() []byte {
+	var prefix bytes.Buffer
+	binary.Write(&prefix, binary.LittleEndian, kFuzzTestMagic)
+	binary.Write(&prefix, binary.LittleEndian, uint32(0))
+	return prefix.Bytes()
+}
+
+//nolint:all
+func TestMarshallKFuzzTestArg(t *testing.T) {
+	testCases := []testCase{
+		// This test case validates the encoding of the following structure:
+		//    msg: ptr[in, msghdr_netlink[netlink_msg_xfrm]] {
+		//      msghdr_netlink[netlink_msg_xfrm] {
+		//        addr: nil
+		//        addrlen: len = 0x0 (4 bytes)
+		//        pad = 0x0 (4 bytes)
+		//        vec: ptr[in, iovec[in, netlink_msg_xfrm]] {
+		//          iovec[in, netlink_msg_xfrm] {
+		//            addr: ptr[inout, array[ANYUNION]] {
+		//              array[ANYUNION] {
+		//              }
+		//            }
+		//            len: len = 0x33fe0 (8 bytes)
+		//          }
+		//        }
+		//        vlen: const = 0x1 (8 bytes)
+		//        ctrl: const = 0x0 (8 bytes)
+		//        ctrllen: const = 0x0 (8 bytes)
+		//        f: send_flags = 0x0 (4 bytes)
+		//        pad = 0x0 (4 bytes)
+		//      }
+		//    }
+		{
+			`r0 = openat$cgroup_ro(0xffffffffffffff9c, &(0x7f00000003c0)='cpuacct.stat\x00', 0x26e1, 0x0)
+sendmsg$nl_xfrm(r0, &(0x7f0000000240)={0x0, 0x0, &(0x7f0000000080)={&(0x7f00000001c0)=ANY=[], 0x33fe0}}, 0x0)`,
+			func(p *Prog) Arg {
+				sendMsgCall := p.Calls[1]
+				msgHdr := sendMsgCall.Args[1].(*PointerArg).Res
+				return msgHdr
+			},
+			[]any{
+				uint32(3), // Num regions.
+
+				// Region definitions: (offset, size) pairs.
+				uint32(0), uint32(0x38),
+				uint32(0x40), uint32(0x10),
+				uint32(0x58), uint32(0x0),
+			},
+			[]any{
+				uint32(3),   // Num entries.
+				uint32(0x8), // Bytes of padding.
+
+				// Relocation definitions: (source region, offset, dest region) triplets.
+				uint32(0), uint32(0x00), kFuzzTestRegionIDNull,
+				uint32(0), uint32(0x10), uint32(1),
+				uint32(1), uint32(0x00), uint32(2),
+				uint64(0x0), // 8 bytes of padding.
+			},
+			[]any{
+				// Region 0 data.
+				kFuzzTestPlaceHolderPtr, // `addr` field, placeholder pointer.
+				uint32(0x0),             // `addrlen`.
+				uint32(0x0),             // `pad[4]`.
+				kFuzzTestPlaceHolderPtr, // `vec` field, placeholder pointer.
+				uint64(0x1),             // `vlen`.
+				uint64(0x0),             // `ctrl`.
+				uint64(0x0),             // `ctrllen`.
+				uint32(0x0),             // `f`.
+				uint32(0x0),             // `pad[4]`.
+
+				uint64(0x0), // 8 bytes of padding between regions.
+
+				// Region 1 data.
+				kFuzzTestPlaceHolderPtr, // `addr` field, placeholder pointer.
+				uint64(0x033fe0),        // `len`.
+
+				make([]byte, kFuzzTestPoisonSize), // Inter-region padding.
+
+				[]byte{}, // Region 2 data (empty).
+
+				make([]byte, kFuzzTestPoisonSize), // Tail padding.
+			},
+		},
+		// This test case validates the encoding of the following structure:
+		//      loop_info64 {
+		//        lo_device: const = 0x0 (8 bytes)
+		//        lo_inode: const = 0x0 (8 bytes)
+		//        lo_rdevice: const = 0x0 (8 bytes)
+		//        lo_offset: int64 = 0x1 (8 bytes)
+		//        lo_sizelimit: int64 = 0x8005 (8 bytes)
+		//        lo_number: const = 0x0 (4 bytes)
+		//        lo_enc_type: lo_encrypt_type = 0x0 (4 bytes)
+		//        lo_enc_key_size: int32 = 0x19 (4 bytes)
+		//        lo_flags: lo_flags = 0x1c (4 bytes)
+		//        lo_file_name: buffer: {ef 35 9f 41 3b b9 38 52 f7 d6 a4 ae 6d dd fb
+		//        d1 ce 5d 29 c2 ee 5e 5c a9 00 0f f8 ee 09 e7 37 ff 0e df 11 0f f4 11
+		//        76 39 c2 eb 4b 78 c6 60 e6 77 df 70 19 05 b9 aa fa b4 af aa f7 55 a3
+		//        f6 a0 04} (length 0x40) lo_crypt_name: buffer: {03 6c 47 c6 78 08 20
+		//        d1 cb f7 96 6d 61 fd cf 33 52 63 bd 9b ff bc c2 54 2d ed 71 03 82 59
+		//        ca 17 1c e1 a3 11 ef 54 ec 32 d7 1e 14 ef 3d c1 77 e9 b4 8b 00 00 00
+		//        00 00 00 00 00 00 00 00 00 00 00} (length 0x40) lo_enc_key: buffer:
+		//        {f2 83 59 73 8e 22 9a 4c 66 81 00 00 00 00 00 d3 00 e6 d6 02 00 00
+		//        00 00 00 00 00 00 00 00 00 01} (length 0x20) lo_init: array[int64] {
+		//          int64 = 0x204 (8 bytes)
+		//          int64 = 0x0 (8 bytes)
+		//        }
+		//      }
+		//    }
+		//  ]
+		{
+			`r0 = open(&(0x7f0000000000)='./bus\x00', 0x0, 0x0)
+ioctl$LOOP_SET_STATUS64(r0, 0x4c04, &(0x7f0000000540)={0x0, 0x0, 0x0, 0x1, 0x8005, 0x0, 0x0, 0x19, 0x1c, "ef359f413bb93852f7d6a4ae6dddfbd1ce5d29c2ee5e5ca9000ff8ee09e737ff0edf110ff4117639c2eb4b78c660e677df701905b9aafab4afaaf755a3f6a004", "036c47c6780820d1cbf7966d61fdcf335263bd9bffbcc2542ded71038259ca171ce1a311ef54ec32d71e14ef3dc177e9b48b00", "f28359738e229a4c66810000000000d300e6d602000000000000000000000001", [0x204]})`,
+			func(p *Prog) Arg {
+				ioctlCall := p.Calls[1]
+				ptrArg := ioctlCall.Args[2].(*PointerArg)
+				ret := ptrArg.Res
+				return ret
+			},
+			[]any{
+				uint32(1), // Num regions.
+
+				// Region definitions: (offset, size) pairs.
+				uint32(0), uint32(0xe8),
+			},
+			[]any{
+				uint32(0),        // Num entries.
+				uint32(12),       // Number of bytes of padding.
+				make([]byte, 12), // Padding.
+			},
+			[]any{
+				uint64(0x0),    // `lo_device`.
+				uint64(0x0),    // `lo_inode`.
+				uint64(0x0),    // `lo_rdevice`.
+				uint64(0x1),    // `lo_offset`.
+				uint64(0x8005), // `lo_sizelimit`.
+				uint32(0x0),    // `lo_number`.
+				uint32(0x0),    // `lo_enc_type`.
+				uint32(0x19),   // `lo_enc_key_size`.
+				uint32(0x1c),   // `lo_flags`.
+				[]byte{
+					0xef, 0x35, 0x9f, 0x41, 0x3b, 0xb9, 0x38, 0x52,
+					0xf7, 0xd6, 0xa4, 0xae, 0x6d, 0xdd, 0xfb, 0xd1,
+					0xce, 0x5d, 0x29, 0xc2, 0xee, 0x5e, 0x5c, 0xa9,
+					0x00, 0x0f, 0xf8, 0xee, 0x09, 0xe7, 0x37, 0xff,
+					0x0e, 0xdf, 0x11, 0x0f, 0xf4, 0x11, 0x76, 0x39,
+					0xc2, 0xeb, 0x4b, 0x78, 0xc6, 0x60, 0xe6, 0x77,
+					0xdf, 0x70, 0x19, 0x05, 0xb9, 0xaa, 0xfa, 0xb4,
+					0xaf, 0xaa, 0xf7, 0x55, 0xa3, 0xf6, 0xa0, 0x04,
+				}, // `lo_file_name`.
+				[]byte{
+					0x03, 0x6c, 0x47, 0xc6, 0x78, 0x08, 0x20, 0xd1,
+					0xcb, 0xf7, 0x96, 0x6d, 0x61, 0xfd, 0xcf, 0x33,
+					0x52, 0x63, 0xbd, 0x9b, 0xff, 0xbc, 0xc2, 0x54,
+					0x2d, 0xed, 0x71, 0x03, 0x82, 0x59, 0xca, 0x17,
+					0x1c, 0xe1, 0xa3, 0x11, 0xef, 0x54, 0xec, 0x32,
+					0xd7, 0x1e, 0x14, 0xef, 0x3d, 0xc1, 0x77, 0xe9,
+					0xb4, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				}, // `lo_crypt_name`.
+				[]byte{
+					0xf2, 0x83, 0x59, 0x73, 0x8e, 0x22, 0x9a, 0x4c,
+					0x66, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd3,
+					0x00, 0xe6, 0xd6, 0x02, 0x00, 0x00, 0x00, 0x00,
+					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+				}, // `lo_enc_key`.
+				uint64(0x204), // `lo_init[0].
+				uint64(0x0),   // `lo_init[1].
+
+				make([]byte, kFuzzTestPoisonSize), // Tail padding.
+			},
+		},
+	}
+
+	for _, tc := range testCases {
+		testOne(t, tc)
+	}
+}
+
+func testOne(t *testing.T, tc testCase) {
+	target, err := GetTarget("linux", "amd64")
+	if err != nil {
+		t.Fatal(err)
+	}
+	p, err := target.Deserialize([]byte(tc.prog), NonStrict)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	arg := tc.extractArg(p)
+	encoded := MarshallKFuzztestArg(arg)
+
+	wantPrefix := createPrefix()
+	wantRegionArray := createBuffer(tc.regionArray)
+	wantRelocTable := createBuffer(tc.relocationTable)
+	wantPayload := createBuffer(tc.payload)
+
+	regionArrayLen := len(wantRegionArray)
+	relocTableLen := len(wantRelocTable)
+	payloadLen := len(wantPayload)
+
+	if len(encoded) != kFuzzTestPrefixSize+regionArrayLen+relocTableLen+payloadLen {
+		t.Fatalf("encoded output has wrong total length: got %d, want %d",
+			len(encoded), regionArrayLen+relocTableLen+payloadLen)
+	}
+
+	gotPrefix := encoded[:kFuzzTestPrefixSize]
+	gotRegionArray := encoded[kFuzzTestPrefixSize : kFuzzTestPrefixSize+regionArrayLen]
+	gotRelocTable := encoded[kFuzzTestPrefixSize+regionArrayLen : kFuzzTestPrefixSize+regionArrayLen+relocTableLen]
+	gotPayload := encoded[kFuzzTestPrefixSize+regionArrayLen+relocTableLen:]
+
+	assert.Equal(t, wantPrefix, gotPrefix)
+	assert.Equal(t, wantRegionArray, gotRegionArray)
+	assert.Equal(t, wantRelocTable, gotRelocTable)
+	assert.Equal(t, wantPayload, gotPayload)
+}
diff --git a/prog/mutation.go b/prog/mutation.go
index eb9e8285d..ecae81608 100644
--- a/prog/mutation.go
+++ b/prog/mutation.go
@@ -145,6 +145,9 @@ func (ctx *mutator) squashAny() bool {
 	if ctx.noMutate[ptr.call.Meta.ID] {
 		return false
 	}
+	if ptr.call.Meta.Attrs.NoSquash {
+		return false
+	}
 	if !p.Target.isAnyPtr(ptr.arg.Type()) {
 		p.Target.squashPtr(ptr.arg)
 	}
@@ -224,13 +227,20 @@ func (ctx *mutator) mutateArg() bool {
 		return false
 	}
 	c := p.Calls[idx]
+	if c.Meta.Attrs.KFuzzTest {
+		tmp := r.genKFuzzTest
+		r.genKFuzzTest = true
+		defer func() {
+			r.genKFuzzTest = tmp
+		}()
+	}
 	if ctx.noMutate[c.Meta.ID] {
 		return false
 	}
 	updateSizes := true
 	for stop, ok := false, false; !stop; stop = ok && r.oneOf(ctx.opts.MutateArgCount) {
 		ok = true
-		ma := &mutationArgs{target: p.Target}
+		ma := &mutationArgs{target: p.Target, ignoreLengths: c.Meta.Attrs.KFuzzTest}
 		ForeachArg(c, ma.collectArg)
 		if len(ma.args) == 0 {
 			return false
@@ -268,7 +278,7 @@ func chooseCall(p *Prog, r *randGen) int {
 	for _, c := range p.Calls {
 		var totalPrio float64
 		ForeachArg(c, func(arg Arg, ctx *ArgCtx) {
-			prio, stopRecursion := arg.Type().getMutationPrio(p.Target, arg, false)
+			prio, stopRecursion := arg.Type().getMutationPrio(p.Target, arg, false, c.Meta.Attrs.KFuzzTest)
 			totalPrio += prio
 			ctx.Stop = stopRecursion
 		})
@@ -506,7 +516,10 @@ func (t *ArrayType) mutate(r *randGen, s *state, arg Arg, ctx ArgCtx) (calls []*
 
 func (t *PtrType) mutate(r *randGen, s *state, arg Arg, ctx ArgCtx) (calls []*Call, retry, preserve bool) {
 	a := arg.(*PointerArg)
-	if r.oneOf(1000) {
+	// Do not generate special pointers for KFuzzTest calls, as they are
+	// difficult to identify in the kernel and can lead to false positive
+	// crash reports.
+	if r.oneOf(1000) && !r.genKFuzzTest {
 		removeArg(a.Res)
 		index := r.rand(len(r.target.SpecialPointers))
 		newArg := MakeSpecialPointerArg(t, a.Dir(), index)
@@ -562,6 +575,7 @@ func (t *ConstType) mutate(r *randGen, s *state, arg Arg, ctx ArgCtx) (calls []*
 type mutationArgs struct {
 	target        *Target
 	ignoreSpecial bool
+	ignoreLengths bool
 	prioSum       float64
 	args          []mutationArg
 	argsBuffer    [16]mutationArg
@@ -584,7 +598,7 @@ func (ma *mutationArgs) collectArg(arg Arg, ctx *ArgCtx) {
 	ma.ignoreSpecial = false
 
 	typ := arg.Type()
-	prio, stopRecursion := typ.getMutationPrio(ma.target, arg, ignoreSpecial)
+	prio, stopRecursion := typ.getMutationPrio(ma.target, arg, ignoreSpecial, ma.ignoreLengths)
 	ctx.Stop = stopRecursion
 
 	if prio == dontMutate {
@@ -614,7 +628,8 @@ func (ma *mutationArgs) chooseArg(r *rand.Rand) (Arg, ArgCtx) {
 // TODO: find a way to estimate optimal priority values.
 // Assign a priority for each type. The boolean is the reference type and it has
 // the minimum priority, since it has only two possible values.
-func (t *IntType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *IntType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	// For a integer without a range of values, the priority is based on
 	// the number of bits occupied by the underlying type.
 	plainPrio := math.Log2(float64(t.TypeBitSize())) + 0.1*maxPriority
@@ -647,14 +662,16 @@ func (t *IntType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (
 	return prio, false
 }
 
-func (t *StructType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *StructType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	if target.SpecialTypes[t.Name()] == nil || ignoreSpecial {
 		return dontMutate, false
 	}
 	return maxPriority, true
 }
 
-func (t *UnionType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *UnionType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	if target.SpecialTypes[t.Name()] == nil && len(t.Fields) == 1 || ignoreSpecial {
 		return dontMutate, false
 	}
@@ -666,7 +683,8 @@ func (t *UnionType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool)
 	return maxPriority, true
 }
 
-func (t *FlagsType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *FlagsType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	prio = rangeSizePrio(uint64(len(t.Vals)))
 	if t.BitMask {
 		// We want a higher priority because the mutation will include
@@ -691,7 +709,8 @@ func rangeSizePrio(size uint64) (prio float64) {
 	return prio
 }
 
-func (t *PtrType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *PtrType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	if arg.(*PointerArg).IsSpecial() {
 		// TODO: we ought to mutate this, but we don't have code for this yet.
 		return dontMutate, false
@@ -699,32 +718,42 @@ func (t *PtrType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (
 	return 0.3 * maxPriority, false
 }
 
-func (t *ConstType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *ConstType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	return dontMutate, false
 }
 
-func (t *CsumType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *CsumType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	return dontMutate, false
 }
 
-func (t *ProcType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *ProcType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	return 0.5 * maxPriority, false
 }
 
-func (t *ResourceType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *ResourceType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	return 0.5 * maxPriority, false
 }
 
-func (t *VmaType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *VmaType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	return 0.5 * maxPriority, false
 }
 
-func (t *LenType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *LenType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	// Mutating LenType only produces "incorrect" results according to descriptions.
+	if ignoreLengths {
+		return dontMutate, false
+	}
 	return 0.1 * maxPriority, false
 }
 
-func (t *BufferType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *BufferType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	if arg.Dir() == DirOut && !t.Varlen() {
 		return dontMutate, false
 	}
@@ -739,7 +768,8 @@ func (t *BufferType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool
 	return 0.8 * maxPriority, false
 }
 
-func (t *ArrayType) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool) {
+func (t *ArrayType) getMutationPrio(target *Target, arg Arg,
+	ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool) {
 	if t.Kind == ArrayRangeLen && t.RangeBegin == t.RangeEnd {
 		return dontMutate, false
 	}
diff --git a/prog/mutation_test.go b/prog/mutation_test.go
index 1cd18656e..d9734b482 100644
--- a/prog/mutation_test.go
+++ b/prog/mutation_test.go
@@ -165,6 +165,32 @@ func TestMutateArgument(t *testing.T) {
 	}
 }
 
+func TestMutateNoSquash(t *testing.T) {
+	target := initTargetTest(t, "test", "64")
+	p, err := target.Deserialize([]byte(`mutate_no_squash(&(0x7f0000000000)={0x1, 0x2, 0x3, 0x4, "5e9ce23b"})`), Strict)
+	if err != nil {
+		t.Fatal(err)
+	}
+	rs := rand.NewSource(0)
+	r := newRand(target, rs)
+	ctx := &mutator{
+		p:      p,
+		r:      r,
+		ncalls: 1,
+		ct:     target.DefaultChoiceTable(),
+		opts:   DefaultMutateOpts,
+	}
+
+	// squashAny should not mutate the program.
+	for i := 0; i < 100; i++ {
+		p1 := p.Clone()
+		ctx.p = p1
+		if ctx.squashAny() {
+			t.Fatalf("squashAny mutated a no_squash call: %s", p1.Serialize())
+		}
+	}
+}
+
 func TestSizeMutateArg(t *testing.T) {
 	target, rs, iters := initRandomTargetTest(t, "test", "64")
 	r := newRand(target, rs)
diff --git a/prog/rand.go b/prog/rand.go
index 957cf7112..d54ef0dfe 100644
--- a/prog/rand.go
+++ b/prog/rand.go
@@ -21,6 +21,10 @@ const (
 	// "Recommended" max number of calls in programs.
 	// If we receive longer programs from hub/corpus we discard them.
 	MaxCalls = 40
+	// "Recommended" number of calls in KFuzzTest mode. These targets test the behavior
+	// of internal kernel functions rather than system behavior, and for this reason
+	// it is more sensible to generate a smaller number of calls instead of long chains.
+	RecommendedCallsKFuzzTest = 5
 )
 
 type randGen struct {
@@ -28,6 +32,7 @@ type randGen struct {
 	target                *Target
 	inGenerateResource    bool
 	patchConditionalDepth int
+	genKFuzzTest          bool
 	recDepth              map[string]int
 }
 
@@ -354,7 +359,9 @@ func (r *randGen) randString(s *state, t *BufferType) []byte {
 			buf.Write([]byte{byte(r.Intn(256))})
 		}
 	}
-	if r.oneOf(100) == t.NoZ {
+	// We always null-terminate strings that are inputs to KFuzzTest calls to
+	// avoid false-positive buffer overflow reports.
+	if r.oneOf(100) == t.NoZ || r.genKFuzzTest {
 		buf.Write([]byte{0})
 	}
 	return buf.Bytes()
@@ -609,6 +616,16 @@ func (r *randGen) generateParticularCall(s *state, meta *Syscall) (calls []*Call
 		panic(fmt.Sprintf("generating no_generate call: %v", meta.Name))
 	}
 	c := MakeCall(meta, nil)
+	// KFuzzTest calls restrict mutation and generation. Since calls to
+	// generateParticularCall can be recursive, we save the previous value, and
+	// set it true.
+	if c.Meta.Attrs.KFuzzTest {
+		tmp := r.genKFuzzTest
+		r.genKFuzzTest = true
+		defer func() {
+			r.genKFuzzTest = tmp
+		}()
+	}
 	c.Args, calls = r.generateArgs(s, meta.Args, DirIn)
 	moreCalls, _ := r.patchConditionalFields(c, s)
 	r.target.assignSizesCall(c)
diff --git a/prog/target.go b/prog/target.go
index 11127046b..300a86a32 100644
--- a/prog/target.go
+++ b/prog/target.go
@@ -127,6 +127,17 @@ func AllTargets() []*Target {
 	return res
 }
 
+// Extend extends a target with a new set of syscalls, types, and resources.
+// It is assumed that all new syscalls, types, and resources do not conflict
+// with those already present in the target.
+func (target *Target) Extend(syscalls []*Syscall, types []Type, resources []*ResourceDesc) {
+	target.Syscalls = append(target.Syscalls, syscalls...)
+	target.Types = append(target.Types, types...)
+	target.Resources = append(target.Resources, resources...)
+	// Updates the system call map and restores any links.
+	target.initTarget()
+}
+
 func (target *Target) lazyInit() {
 	target.Neutralize = func(c *Call, fixStructure bool) error { return nil }
 	target.AnnotateCall = func(c ExecCall) string { return "" }
@@ -135,6 +146,10 @@ func (target *Target) lazyInit() {
 	target.initUselessHints()
 	target.initRelatedFields()
 	target.initArch(target)
+	// We ignore the return value here as they are cached, and it makes more
+	// sense to react to them when we attempt to execute a KFuzzTest call.
+	_, _ = target.KFuzzTestRunID()
+
 	// Give these 2 known addresses fixed positions and prepend target-specific ones at the end.
 	target.SpecialPointers = append([]uint64{
 		0x0000000000000000, // NULL pointer (keep this first because code uses special index=0 as NULL)
@@ -153,8 +168,6 @@ func (target *Target) lazyInit() {
 			panic(fmt.Sprintf("bad special file length %v", ln))
 		}
 	}
-	// These are used only during lazyInit.
-	target.Types = nil
 }
 
 func (target *Target) initTarget() {
@@ -522,3 +535,24 @@ func (pg *Builder) Finalize() (*Prog, error) {
 	pg.p = nil
 	return p, nil
 }
+
+var kFuzzTestIDCache struct {
+	sync.Once
+	id  int
+	err error
+}
+
+// KFuzzTestRunID returns the ID for the syz_kfuzztest_run pseudo-syscall,
+// or an error if it is not found in the target.
+func (t *Target) KFuzzTestRunID() (int, error) {
+	kFuzzTestIDCache.Do(func() {
+		for _, call := range t.Syscalls {
+			if call.Attrs.KFuzzTest {
+				kFuzzTestIDCache.id = call.ID
+				return
+			}
+		}
+		kFuzzTestIDCache.err = fmt.Errorf("could not find ID for syz_kfuzztest_run - does it exist?")
+	})
+	return kFuzzTestIDCache.id, kFuzzTestIDCache.err
+}
diff --git a/prog/types.go b/prog/types.go
index 3bf7d640e..2329c348f 100644
--- a/prog/types.go
+++ b/prog/types.go
@@ -44,9 +44,11 @@ type SyscallAttrs struct {
 	BreaksReturns   bool
 	NoGenerate      bool
 	NoMinimize      bool
+	NoSquash        bool
 	RemoteCover     bool
 	Automatic       bool
 	AutomaticHelper bool
+	KFuzzTest       bool
 	Fsck            string
 	// Filesystem is used in tools/syz-imagegen when fs name cannot be deduced from
 	// the part after $.
@@ -192,7 +194,7 @@ type Type interface {
 	isDefaultArg(arg Arg) bool
 	generate(r *randGen, s *state, dir Dir) (arg Arg, calls []*Call)
 	mutate(r *randGen, s *state, arg Arg, ctx ArgCtx) (calls []*Call, retry, preserve bool)
-	getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (prio float64, stopRecursion bool)
+	getMutationPrio(target *Target, arg Arg, ignoreSpecial, ignoreLengths bool) (prio float64, stopRecursion bool)
 	minimize(ctx *minimizeArgsCtx, arg Arg, path string) bool
 	ref() Ref
 	setRef(ref Ref)
@@ -222,7 +224,7 @@ func (ti Ref) generate(r *randGen, s *state, dir Dir) (Arg, []*Call) { panic("pr
 func (ti Ref) mutate(r *randGen, s *state, arg Arg, ctx ArgCtx) ([]*Call, bool, bool) {
 	panic("prog.Ref method called")
 }
-func (ti Ref) getMutationPrio(target *Target, arg Arg, ignoreSpecial bool) (float64, bool) {
+func (ti Ref) getMutationPrio(target *Target, arg Arg, ignoreSpecial, ignoreLengths bool) (float64, bool) {
 	panic("prog.Ref method called")
 }
 func (ti Ref) minimize(ctx *minimizeArgsCtx, arg Arg, path string) bool {
diff --git a/prog/validation.go b/prog/validation.go
index 48a6efade..3fec567b9 100644
--- a/prog/validation.go
+++ b/prog/validation.go
@@ -31,11 +31,12 @@ func (p *Prog) validate() error {
 }
 
 type validCtx struct {
-	target   *Target
-	isUnsafe bool
-	opts     validationOptions
-	args     map[Arg]bool
-	uses     map[Arg]Arg
+	target      *Target
+	isUnsafe    bool
+	opts        validationOptions
+	args        map[Arg]bool
+	uses        map[Arg]Arg
+	currentCall *Call
 }
 
 type validationOptions struct {
@@ -54,10 +55,12 @@ func (p *Prog) validateWithOpts(opts validationOptions) error {
 		if c.Meta == nil {
 			return fmt.Errorf("call does not have meta information")
 		}
+		ctx.currentCall = c
 		if err := ctx.validateCall(c); err != nil {
 			return fmt.Errorf("call #%d %v: %w", i, c.Meta.Name, err)
 		}
 	}
+	ctx.currentCall = nil
 	for u, orig := range ctx.uses {
 		if !ctx.args[u] {
 			return fmt.Errorf("use of %+v referes to an out-of-tree arg\narg: %#v", orig, u)
@@ -128,6 +131,9 @@ func (ctx *validCtx) validateArg(arg Arg, typ Type, dir Dir) error {
 	if !ctx.target.isAnyPtr(arg.Type()) && arg.Type() != typ {
 		return fmt.Errorf("bad arg type %#v, expect %#v", arg.Type(), typ)
 	}
+	if ctx.currentCall.Meta.Attrs.NoSquash && ctx.target.isAnyPtr(arg.Type()) {
+		return fmt.Errorf("ANY argument for no_squash call %v", ctx.currentCall.Meta.Name)
+	}
 	ctx.args[arg] = true
 	return arg.validate(ctx, dir)
 }
diff --git a/sys/linux/dev_kvm.txt b/sys/linux/dev_kvm.txt
index 919fcc3aa..ec342b320 100644
--- a/sys/linux/dev_kvm.txt
+++ b/sys/linux/dev_kvm.txt
@@ -78,8 +78,6 @@ ioctl$KVM_GET_ONE_REG(fd fd_kvmcpu, cmd const[KVM_GET_ONE_REG], arg ptr[in, kvm_
 ioctl$KVM_KVMCLOCK_CTRL(fd fd_kvmcpu, cmd const[KVM_KVMCLOCK_CTRL])
 ioctl$KVM_S390_INTERRUPT_CPU(fd fd_kvmcpu, cmd const[KVM_S390_INTERRUPT], arg ptr[in, kvm_s390_interrupt])
 ioctl$KVM_GET_REG_LIST(fd fd_kvmcpu, cmd const[KVM_GET_REG_LIST], arg ptr[inout, kvm_reg_list])
-ioctl$KVM_SET_GUEST_DEBUG(fd fd_kvmcpu, cmd const[KVM_SET_GUEST_DEBUG], arg ptr[in, kvm_guest_debug])
-
 ioctl$KVM_SET_DEVICE_ATTR(fd fd_kvmdev, cmd const[KVM_SET_DEVICE_ATTR], arg ptr[in, kvm_device_attr])
 ioctl$KVM_GET_DEVICE_ATTR(fd fd_kvmdev, cmd const[KVM_GET_DEVICE_ATTR], arg ptr[in, kvm_device_attr])
 ioctl$KVM_HAS_DEVICE_ATTR(fd fd_kvmdev, cmd const[KVM_HAS_DEVICE_ATTR], arg ptr[in, kvm_device_attr])
@@ -108,7 +106,7 @@ kvm_ioeventfd_flags = KVM_IOEVENTFD_FLAG_DATAMATCH, KVM_IOEVENTFD_FLAG_PIO, KVM_
 kvm_ioeventfd_len = 0, 1, 2, 4, 8
 kvm_device_type = KVM_DEV_TYPE_FSL_MPIC_20, KVM_DEV_TYPE_FSL_MPIC_42, KVM_DEV_TYPE_XICS, KVM_DEV_TYPE_VFIO, KVM_DEV_TYPE_ARM_VGIC_V2, KVM_DEV_TYPE_FLIC, KVM_DEV_TYPE_ARM_VGIC_V3, KVM_DEV_TYPE_ARM_VGIC_ITS, KVM_DEV_TYPE_XIVE, KVM_DEV_TYPE_ARM_PV_TIME, KVM_DEV_TYPE_RISCV_AIA
 kvm_device_flags = 0, KVM_CREATE_DEVICE_TEST
-kvm_guest_debug_flags = KVM_GUESTDBG_ENABLE, KVM_GUESTDBG_SINGLESTEP, KVM_GUESTDBG_USE_SW_BP, KVM_GUESTDBG_USE_HW_BP, KVM_GUESTDBG_INJECT_DB, KVM_GUESTDBG_INJECT_BP, KVM_GUESTDBG_EXIT_PENDING, KVM_GUESTDBG_BLOCKIRQ
+kvm_guest_debug_flags = KVM_GUESTDBG_ENABLE, KVM_GUESTDBG_SINGLESTEP, KVM_GUESTDBG_USE_SW_BP, KVM_GUESTDBG_USE_HW_BP, KVM_GUESTDBG_USE_HW, KVM_GUESTDBG_INJECT_DB, KVM_GUESTDBG_INJECT_BP, KVM_GUESTDBG_EXIT_PENDING, KVM_GUESTDBG_BLOCKIRQ
 kvm_guest_selector = 0, 3, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16
 kvm_dirty_log_protect = KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE, KVM_DIRTY_LOG_INITIALLY_SET
 kvm_dirty_log_sizes = 4096, 8192, 16384, 32768, 65536
@@ -166,10 +164,10 @@ define KVM_SETUP_PPC64_PR	(1<<3)
 # Set PID=1 i.e. not kernel's PID
 define KVM_SETUP_PPC64_PID1	(1<<4)
 
-kvm_guest_debug {
+type kvm_guest_debug[ARCH] {
 	ctrl	flags[kvm_guest_debug_flags, int32]
 	pad	const[0, int32]
-	reg	array[int64, 8]
+	arch	ARCH
 }
 
 kvm_reg_list {
diff --git a/sys/linux/dev_kvm.txt.const b/sys/linux/dev_kvm.txt.const
index 7f313efdb..b43af3832 100644
--- a/sys/linux/dev_kvm.txt.const
+++ b/sys/linux/dev_kvm.txt.const
@@ -84,6 +84,7 @@ KVM_GUESTDBG_EXIT_PENDING = 386:amd64:arm64:mips64le:ppc64le:???, s390x:26843545
 KVM_GUESTDBG_INJECT_BP = 524288, arm64:mips64le:ppc64le:s390x:???
 KVM_GUESTDBG_INJECT_DB = 262144, arm64:mips64le:ppc64le:s390x:???
 KVM_GUESTDBG_SINGLESTEP = 2
+KVM_GUESTDBG_USE_HW = 386:amd64:mips64le:ppc64le:s390x:???, arm64:131072
 KVM_GUESTDBG_USE_HW_BP = 131072, arm64:mips64le:???, s390x:65536
 KVM_GUESTDBG_USE_SW_BP = 65536, mips64le:s390x:???
 KVM_HAS_DEVICE_ATTR = 1075359459, mips64le:ppc64le:2149101283
diff --git a/sys/linux/dev_kvm_amd64.txt b/sys/linux/dev_kvm_amd64.txt
index 14c27edd1..43474f9f6 100644
--- a/sys/linux/dev_kvm_amd64.txt
+++ b/sys/linux/dev_kvm_amd64.txt
@@ -19,10 +19,12 @@ resource sev_handle[int32]
 syz_kvm_setup_syzos_vm$x86(fd fd_kvmvm, usermem vma[1024]) kvm_syz_vm$x86
 
 # Create a VCPU inside a kvm_syz_vm VM.
-syz_kvm_add_vcpu$x86(vm kvm_syz_vm$x86, text ptr[in, kvm_text$x86]) fd_kvmcpu
+# Prohibit flattening the input arguments, so that it is easier to reason about them.
+syz_kvm_add_vcpu$x86(vm kvm_syz_vm$x86, text ptr[in, kvm_text$x86]) fd_kvmcpu (no_squash)
 
 # Test assertions, will not be used by the fuzzer.
 syz_kvm_assert_syzos_uexit$x86(run kvm_run_ptr, exitcode intptr) (no_generate)
+syz_kvm_assert_syzos_kvm_exit$x86(run kvm_run_ptr, exitcode intptr) (no_generate)
 
 # Pseudo call that setups VCPU into a reasonable interesting state for execution.
 # The interface is designed for extensibility so that addition of new options does not invalidate all existing programs.
@@ -67,6 +69,26 @@ syzos_api_wr_crn {
 	arg_value	int64
 }
 
+# Depending on CR4.DE, registers DR4 and DR5 either alias DR6 and DR7, or generate an #UD.
+syzos_api_wr_drn {
+	arg_reg		int64[0:7]
+	arg_value	int64
+}
+
+x86_in_out_size = 1, 2, 4
+
+syzos_api_in_dx {
+	arg_port	int64[0:65535]
+	arg_size	flags[x86_in_out_size, int64]
+}
+
+# In fact the accepted value always fit into int32.
+syzos_api_out_dx {
+	arg_port	int64[0:65535]
+	arg_size	flags[x86_in_out_size, int64]
+	arg_val		int64
+}
+
 syzos_api_call$x86 [
 	uexit	syzos_api$x86[0, intptr]
 	code	syzos_api$x86[10, syzos_api_code$x86]
@@ -74,6 +96,9 @@ syzos_api_call$x86 [
 	wrmsr	syzos_api$x86[30, syzos_api_wrmsr]
 	rdmsr	syzos_api$x86[50, syzos_api_rdmsr]
 	wr_crn	syzos_api$x86[70, syzos_api_wr_crn]
+	wr_drn	syzos_api$x86[110, syzos_api_wr_drn]
+	in_dx	syzos_api$x86[130, syzos_api_in_dx]
+	out_dx	syzos_api$x86[170, syzos_api_out_dx]
 ] [varlen]
 
 kvm_text_x86 [
@@ -458,6 +483,7 @@ ioctl$KVM_GET_FPU(fd fd_kvmcpu, cmd const[KVM_GET_FPU], arg ptr[out, kvm_fpu])
 ioctl$KVM_SET_FPU(fd fd_kvmcpu, cmd const[KVM_SET_FPU], arg ptr[in, kvm_fpu])
 ioctl$KVM_GET_DEBUGREGS(fd fd_kvmcpu, cmd const[KVM_GET_DEBUGREGS], arg ptr[out, kvm_debugregs])
 ioctl$KVM_SET_DEBUGREGS(fd fd_kvmcpu, cmd const[KVM_SET_DEBUGREGS], arg ptr[in, kvm_debugregs])
+ioctl$KVM_SET_GUEST_DEBUG_x86(fd fd_kvmcpu, cmd const[KVM_SET_GUEST_DEBUG], arg ptr[in, kvm_guest_debug[kvm_guest_debug_arch_x86]])
 ioctl$KVM_GET_XCRS(fd fd_kvmcpu, cmd const[KVM_GET_XCRS], arg ptr[out, kvm_xcrs])
 ioctl$KVM_SET_XCRS(fd fd_kvmcpu, cmd const[KVM_SET_XCRS], arg ptr[in, kvm_xcrs])
 ioctl$KVM_GET_XSAVE(fd fd_kvmcpu, cmd const[KVM_GET_XSAVE], arg ptr[out, kvm_xsave])
@@ -494,6 +520,10 @@ ioctl$KVM_GET_XSAVE2(fd fd_kvmcpu, cmd const[KVM_GET_XSAVE2], arg vma)
 ioctl$KVM_GET_SREGS2(fd fd_kvmcpu, cmd const[KVM_GET_SREGS2], arg ptr[out, kvm_sregs2])
 ioctl$KVM_SET_SREGS2(fd fd_kvmcpu, cmd const[KVM_SET_SREGS2], arg ptr[in, kvm_sregs2])
 
+kvm_guest_debug_arch_x86 {
+	reg	array[int64, 8]
+}
+
 kvm_nested_state {
 	flags	flags[kvm_nested_state_flags, int16]
 	format	const[0, int16]
diff --git a/sys/linux/dev_kvm_arm64.txt b/sys/linux/dev_kvm_arm64.txt
index 9a6d8dffd..f4c724606 100644
--- a/sys/linux/dev_kvm_arm64.txt
+++ b/sys/linux/dev_kvm_arm64.txt
@@ -18,7 +18,8 @@ resource kvm_syz_vm$arm64[int64]
 syz_kvm_setup_syzos_vm$arm64(fd fd_kvmvm, usermem vma[1024]) kvm_syz_vm$arm64
 
 # Create a VCPU inside a kvm_syz_vm VM.
-syz_kvm_add_vcpu$arm64(vm kvm_syz_vm$arm64, text ptr[in, kvm_text_arm64], opts ptr[in, array[kvm_setup_opt_arm64, 1]], nopt len[opts]) fd_kvmcpu
+# Prohibit flattening the input arguments, so that it is easier to reason about them.
+syz_kvm_add_vcpu$arm64(vm kvm_syz_vm$arm64, text ptr[in, kvm_text_arm64], opts ptr[in, array[kvm_setup_opt_arm64, 1]], nopt len[opts]) fd_kvmcpu (no_squash)
 
 kvm_num_irqs = 32, 64, 128, 256, 512
 
@@ -28,6 +29,7 @@ syz_kvm_vgic_v3_setup(fd fd_kvmvm, ncpus intptr[0:4], nirqs flags[kvm_num_irqs])
 # Test assertions, will not be used by the fuzzer.
 syz_kvm_assert_syzos_uexit$arm64(run kvm_run_ptr, exitcode int64) (no_generate)
 syz_kvm_assert_reg(fd fd_kvmcpu, reg int64, value int64) (no_generate)
+syz_kvm_assert_syzos_kvm_exit$arm64(run kvm_run_ptr, exitcode int64) (no_generate)
 
 # Old-style way to set up a CPU inside a KVM VM.
 syz_kvm_setup_cpu$arm64(fd fd_kvmvm, cpufd fd_kvmcpu, usermem vma[1024], text ptr[in, array[kvm_text_arm64, 1]], ntext len[text], flags const[0], opts ptr[in, array[kvm_setup_opt_arm64, 1]], nopt len[opts])
@@ -56,6 +58,15 @@ kvm_arm_device_addr {
 	addr	flags[kvm_guest_addrs, int64]
 }
 
+kvm_guest_debug_arch_arm64 {
+	dbg_bcr	array[int64, 16]
+	dbg_bvr	array[int64, 16]
+	dbg_wcr	array[int64, 16]
+	dbg_wvr	array[int64, 16]
+}
+
+ioctl$KVM_SET_GUEST_DEBUG_arm64(fd fd_kvmcpu, cmd const[KVM_SET_GUEST_DEBUG], arg ptr[in, kvm_guest_debug[kvm_guest_debug_arch_arm64]])
+
 ioctl$KVM_ARM_VCPU_INIT(fd fd_kvmcpu, cmd const[KVM_ARM_VCPU_INIT], arg ptr[in, kvm_vcpu_init])
 ioctl$KVM_ARM_PREFERRED_TARGET(fd fd_kvmcpu, cmd const[KVM_ARM_PREFERRED_TARGET], arg ptr[out, kvm_vcpu_init])
 # KVM_ARM_VCPU_FINALIZE accepts a single CPU feature encoded as a bit number: https://docs.kernel.org/virt/kvm/api.html#kvm-arm-vcpu-finalize.
diff --git a/sys/linux/dev_kvm_extra.txt b/sys/linux/dev_kvm_extra.txt
new file mode 100644
index 000000000..395ce577d
--- /dev/null
+++ b/sys/linux/dev_kvm_extra.txt
@@ -0,0 +1,12 @@
+# Copyright 2025 syzkaller project authors. All rights reserved.
+# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+# This file is used for non-x86, non-ARM definitions.
+
+meta arches["mips64le", "ppc64le", "s390x"]
+
+ioctl$KVM_SET_GUEST_DEBUG_generic(fd fd_kvmcpu, cmd const[KVM_SET_GUEST_DEBUG], arg ptr[in, kvm_guest_debug[kvm_guest_debug_arch_generic]])
+
+kvm_guest_debug_arch_generic {
+	reg	array[int64, 8]
+}
diff --git a/sys/linux/kfuzztest.txt b/sys/linux/kfuzztest.txt
new file mode 100644
index 000000000..094d50ac0
--- /dev/null
+++ b/sys/linux/kfuzztest.txt
@@ -0,0 +1,4 @@
+# Copyright 2025 syzkaller project authors. All rights reserved.
+# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+syz_kfuzztest_run(name ptr[in, string], data ptr[in, array[int8]], len bytesize[data], buf ptr[in, array[int8, 65536]]) (kfuzz_test, no_generate)
diff --git a/sys/linux/socket_inet_tcp.txt b/sys/linux/socket_inet_tcp.txt
index 3f4f360db..2e354a88e 100644
--- a/sys/linux/socket_inet_tcp.txt
+++ b/sys/linux/socket_inet_tcp.txt
@@ -76,11 +76,11 @@ tcp_zerocopy_receive_flags = TCP_RECEIVE_ZEROCOPY_FLAG_TLB_CLEAN_HINT
 
 # TODO: use TCP_SAVED_SYN to extract sequence numbers
 
-setsockopt$inet_tcp_TCP_CONGESTION(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_CONGESTION], optval ptr[in, string[tcp_congestion_control_alg_names]], optlen len[optval])
-setsockopt$inet6_tcp_TCP_CONGESTION(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_CONGESTION], optval ptr[in, string[tcp_congestion_control_alg_names]], optlen len[optval])
+setsockopt$inet_tcp_TCP_CONGESTION(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_CONGESTION], optval ptr[in, stringnoz[tcp_congestion_control_alg_names]], optlen len[optval])
+setsockopt$inet6_tcp_TCP_CONGESTION(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_CONGESTION], optval ptr[in, stringnoz[tcp_congestion_control_alg_names]], optlen len[optval])
 
-setsockopt$inet_tcp_TCP_ULP(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_ULP], optval ptr[in, string[tcp_ulp_names]], optlen len[optval])
-setsockopt$inet6_tcp_TCP_ULP(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_ULP], optval ptr[in, string[tcp_ulp_names]], optlen len[optval])
+setsockopt$inet_tcp_TCP_ULP(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_ULP], optval ptr[in, stringnoz[tcp_ulp_names]], optlen len[optval])
+setsockopt$inet6_tcp_TCP_ULP(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_ULP], optval ptr[in, stringnoz[tcp_ulp_names]], optlen len[optval])
 
 setsockopt$inet_tcp_TCP_MD5SIG(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_MD5SIG], optval ptr[in, tcp_md5sig], optlen len[optval])
 setsockopt$inet6_tcp_TCP_MD5SIG(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_MD5SIG], optval ptr[in, tcp_md5sig], optlen len[optval])
@@ -109,10 +109,10 @@ setsockopt$inet6_tcp_TCP_REPAIR_WINDOW(fd sock_tcp6, level const[IPPROTO_TCP], o
 setsockopt$inet_tcp_TCP_FASTOPEN_KEY(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_FASTOPEN_KEY], optval ptr[in, array[int8, TCP_FASTOPEN_KEY_LENGTH]], optlen len[optval])
 setsockopt$inet6_tcp_TCP_FASTOPEN_KEY(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_FASTOPEN_KEY], optval ptr[in, array[int8, TCP_FASTOPEN_KEY_LENGTH]], optlen len[optval])
 
-setsockopt$inet_tcp_TLS_TX(fd sock_tcp, level const[IPPROTO_TCP], optname const[TLS_TX], optval ptr[in, tls_crypto_info_u], optlen len[optval])
-setsockopt$inet6_tcp_TLS_TX(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TLS_TX], optval ptr[in, tls_crypto_info_u], optlen len[optval])
-setsockopt$inet_tcp_TLS_RX(fd sock_tcp, level const[IPPROTO_TCP], optname const[TLS_RX], optval ptr[in, tls_crypto_info_u], optlen len[optval])
-setsockopt$inet6_tcp_TLS_RX(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TLS_RX], optval ptr[in, tls_crypto_info_u], optlen len[optval])
+setsockopt$inet_tcp_TLS_TX(fd sock_tcp, level const[SOL_TLS], optname const[TLS_TX], optval ptr[in, tls_crypto_info_u], optlen len[optval])
+setsockopt$inet6_tcp_TLS_TX(fd sock_tcp6, level const[SOL_TLS], optname const[TLS_TX], optval ptr[in, tls_crypto_info_u], optlen len[optval])
+setsockopt$inet_tcp_TLS_RX(fd sock_tcp, level const[SOL_TLS], optname const[TLS_RX], optval ptr[in, tls_crypto_info_u], optlen len[optval])
+setsockopt$inet6_tcp_TLS_RX(fd sock_tcp6, level const[SOL_TLS], optname const[TLS_RX], optval ptr[in, tls_crypto_info_u], optlen len[optval])
 
 tcp_congestion_control_alg_names = "cubic", "reno", "bic", "cdg", "dctcp", "westwood", "highspeed", "hybla", "htcp", "vegas", "nv", "veno", "scalable", "lp", "yeah", "illinois", "dctcp-reno", "bbr"
 
diff --git a/sys/linux/socket_inet_tcp.txt.const b/sys/linux/socket_inet_tcp.txt.const
index b5a15d87d..cf433cffb 100644
--- a/sys/linux/socket_inet_tcp.txt.const
+++ b/sys/linux/socket_inet_tcp.txt.const
@@ -15,6 +15,7 @@ SIOCOUTQ = 21521, mips64le:29810, ppc64le:1074033779
 SIOCOUTQNSD = 35147
 SOCK_STREAM = 1, mips64le:2
 SOL_MPTCP = 284
+SOL_TLS = 282
 TCPOPT_MSS = 2
 TCPOPT_SACK_PERM = 4
 TCPOPT_TIMESTAMP = 8
diff --git a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm
index 09d6cfe27..0e13a0337 100644
--- a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm
+++ b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm
@@ -23,7 +23,12 @@ syz_kvm_assert_syzos_uexit$x86(r5, 0x0)
 #
 ioctl$KVM_RUN(r3, AUTO, 0x0)
 syz_kvm_assert_syzos_uexit$x86(r5, 0xaaaa)
-# Run till the end of guest_main(). 0xffffffffffffffff is UEXIT_END.
+
+# Run till the end of guest_main().
 #
 ioctl$KVM_RUN(r3, AUTO, 0x0)
+
+# Ensure that exit reason is KVM_EXIT_MMIO and uexit code is UEXIT_END.
+#
+syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x6)
 syz_kvm_assert_syzos_uexit$x86(r5, 0xffffffffffffffff)
diff --git a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-cpuid b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-cpuid
index 34468c8cd..b950fb3a3 100644
--- a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-cpuid
+++ b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-cpuid
@@ -11,7 +11,11 @@ r3 = syz_kvm_add_vcpu$x86(r2, &AUTO={0x0, &AUTO=[@cpuid={AUTO, AUTO, {0x1, 0x0}}
 r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
 r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)
 
-# Run till the end of guest_main(). 0xffffffffffffffff is UEXIT_END.
+# Run till the end of guest_main().
 #
 ioctl$KVM_RUN(r3, AUTO, 0x0)
+
+# Ensure that exit reason is KVM_EXIT_MMIO and uexit code is UEXIT_END.
+#
+syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x6)
 syz_kvm_assert_syzos_uexit$x86(r5, 0xffffffffffffffff)
diff --git a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-hlt b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-hlt
new file mode 100644
index 000000000..1a416ce4e
--- /dev/null
+++ b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-hlt
@@ -0,0 +1,17 @@
+#
+# requires: arch=amd64 -threaded
+#
+r0 = openat$kvm(0, &AUTO='/dev/kvm\x00', 0x0, 0x0)
+r1 = ioctl$KVM_CREATE_VM(r0, AUTO, 0x0)
+r2 = syz_kvm_setup_syzos_vm$x86(r1, &(0x7f0000c00000/0x400000)=nil)
+
+# 0xf4 is the HLT instruction.
+#
+r3 = syz_kvm_add_vcpu$x86(r2, &AUTO={0x0, &AUTO=[@code={AUTO, AUTO, {"f4", 0x1}}], AUTO})
+r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
+r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)
+
+# KVM_RUN should exit with KVM_EXIT_HLT = 0x5.
+#
+ioctl$KVM_RUN(r3, AUTO, 0x0)
+syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x5)
diff --git a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-in_dx-out_dx b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-in_dx-out_dx
new file mode 100644
index 000000000..e6897f68a
--- /dev/null
+++ b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-in_dx-out_dx
@@ -0,0 +1,19 @@
+#
+# requires: arch=amd64 -threaded
+#
+r0 = openat$kvm(0, &AUTO='/dev/kvm\x00', 0x0, 0x0)
+r1 = ioctl$KVM_CREATE_VM(r0, AUTO, 0x0)
+r2 = syz_kvm_setup_syzos_vm$x86(r1, &(0x7f0000c00000/0x400000)=nil)
+
+# Writing to debug register DR3.
+#
+r3 = syz_kvm_add_vcpu$x86(r2, &AUTO={0x0, &AUTO=[@in_dx={AUTO, AUTO, {0x123, 0x2}}, @out_dx={AUTO, AUTO, {0x456, 0x4, 0xffffffff}}], AUTO})
+r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
+r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)
+
+# Ensure that both IN and OUT exit with KVM_EXIT_IO.
+#
+ioctl$KVM_RUN(r3, AUTO, 0x0)
+syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x2)
+ioctl$KVM_RUN(r3, AUTO, 0x0)
+syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x2)
diff --git a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wr_drn b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wr_drn
new file mode 100644
index 000000000..106822d63
--- /dev/null
+++ b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wr_drn
@@ -0,0 +1,22 @@
+#
+# requires: arch=amd64 -threaded
+#
+r0 = openat$kvm(0, &AUTO='/dev/kvm\x00', 0x0, 0x0)
+r1 = ioctl$KVM_CREATE_VM(r0, AUTO, 0x0)
+r2 = syz_kvm_setup_syzos_vm$x86(r1, &(0x7f0000c00000/0x400000)=nil)
+
+# Writing to debug register DR7 will trigger an exit.
+#
+r3 = syz_kvm_add_vcpu$x86(r2, &AUTO={0x0, &AUTO=[@wr_drn={AUTO, AUTO, {0x7, 0x2000}}], AUTO})
+
+# 0x3 = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_SINGLESTEP
+#
+ioctl$KVM_SET_GUEST_DEBUG_x86(r3, AUTO, &AUTO={0x3, 0x0, {[0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]}})
+r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
+r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)
+
+ioctl$KVM_RUN(r3, AUTO, 0x0)
+
+# Ensure that exit reason is KVM_EXIT_DEBUG.
+#
+syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x4)
diff --git a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wr_drn-shutdown b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wr_drn-shutdown
new file mode 100644
index 000000000..ef85a54ff
--- /dev/null
+++ b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wr_drn-shutdown
@@ -0,0 +1,22 @@
+#
+# requires: arch=amd64 -threaded
+#
+r0 = openat$kvm(0, &AUTO='/dev/kvm\x00', 0x0, 0x0)
+r1 = ioctl$KVM_CREATE_VM(r0, AUTO, 0x0)
+r2 = syz_kvm_setup_syzos_vm$x86(r1, &(0x7f0000c00000/0x400000)=nil)
+
+# DR7.GD=1 causes further attempts to touch a debug register to result in a debug exception.
+#
+r3 = syz_kvm_add_vcpu$x86(r2, &AUTO={0x0, &AUTO=[@wr_drn={AUTO, AUTO, {0x7, 0x2000}}, @wr_drn={AUTO, AUTO, {0x0, 0x1}}], AUTO})
+
+# 0x10001 = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP enables software breakpoints.
+#
+ioctl$KVM_SET_GUEST_DEBUG_x86(r3, AUTO, &AUTO={0x10001, 0x0, {[0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]}})
+r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
+r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)
+
+ioctl$KVM_RUN(r3, AUTO, 0x0)
+
+# Ensure that exit reason is KVM_EXIT_SHUTDOWN, because the exception is unhandled.
+#
+syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x8)
diff --git a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wrmsr-rdmsr b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wrmsr-rdmsr
index 519432ca5..2ecf90804 100644
--- a/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wrmsr-rdmsr
+++ b/sys/linux/test/amd64-syz_kvm_setup_syzos_vm-wrmsr-rdmsr
@@ -11,7 +11,11 @@ r3 = syz_kvm_add_vcpu$x86(r2, &AUTO={0x0, &AUTO=[@wrmsr={AUTO, AUTO, {0x1b, 0xff
 r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
 r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)
 
-# Run till the end of guest_main(). 0xffffffffffffffff is UEXIT_END.
+# Run till the end of guest_main().
 #
 ioctl$KVM_RUN(r3, AUTO, 0x0)
+
+# Ensure that exit reason is KVM_EXIT_MMIO and uexit code is UEXIT_END.
+#
+syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x6)
 syz_kvm_assert_syzos_uexit$x86(r5, 0xffffffffffffffff)
diff --git a/sys/linux/test/arm64-kvm-bug367186827 b/sys/linux/test/arm64-kvm-bug367186827
index 12a692793..da6ceb1c7 100644
--- a/sys/linux/test/arm64-kvm-bug367186827
+++ b/sys/linux/test/arm64-kvm-bug367186827
@@ -9,7 +9,12 @@ ioctl$KVM_CREATE_VCPU(r2, 0xae41, 0x2)
 ioctl$KVM_IRQ_LINE(r2, 0x4008ae61, &(0x7f0000000240)={0x200002f, 0x0}) (async)
 r3 = ioctl$KVM_CREATE_VM(r0, 0xae01, 0x0)
 r4 = syz_kvm_setup_syzos_vm$arm64(r3, &(0x7f0000c00000/0x400000)=nil)
-r5 = syz_kvm_add_vcpu$arm64(r4, &(0x7f0000000080)={0x0, &(0x7f0000000000)=ANY=[@ANYBLOB="054c0f0000000060b47892001800000000003b67ed394d2d53cb"], 0x18}, 0x0, 0x0) (async, rerun: 64)
+#
+# The line used to look as follows, but syz_kvm_add_vcpu() does not support ANY anymore.
+# r5 = syz_kvm_add_vcpu$arm64(r4, &(0x7f0000000080)={0x0, &(0x7f0000000000)=ANY=[@ANYBLOB="054c0f0000000060b47892001800000000003b67ed394d2d53cb"], 0x18}, 0x0, 0x0) (async, rerun: 64)
+# Just replaced it with something relevant.
+#
+r5 = syz_kvm_add_vcpu$arm64(r4, &(0x7f0000000080)={0x0, &(0x7f0000000000)=[@irq_setup={0x5, 0x18, {0x1, 0x20}}], 0x18}, 0x0, 0x0) (async, rerun: 64)
 syz_kvm_vgic_v3_setup(r3, 0x1, 0x100)
 ioctl$KVM_RUN(r5, 0xae80, 0x0) (async)
 ioctl$KVM_IRQ_LINE(r3, 0x4008ae61, &(0x7f0000000100)={0x1000020, 0x1}) (async, rerun: 32)
diff --git a/sys/linux/test/arm64-kvm-bug370977056 b/sys/linux/test/arm64-kvm-bug370977056
index 4d0cfcdb1..fe000bd80 100644
--- a/sys/linux/test/arm64-kvm-bug370977056
+++ b/sys/linux/test/arm64-kvm-bug370977056
@@ -18,7 +18,12 @@ ioctl$KVM_IOEVENTFD(0xffffffffffffffff, 0x4040ae79, &(0x7f0000000100))
 r8 = ioctl$KVM_CREATE_VM(r0, 0xae01, 0x0)
 r9 = syz_kvm_setup_syzos_vm$arm64(r8, &(0x7f0000c00000/0x400000)=nil)
 r10 = syz_kvm_add_vcpu$arm64(r9, &(0x7f0000000080)={0x0, &(0x7f00000000c0)=[@irq_setup={0x5, 0x18, {0x1, 0x20}}], 0x18}, 0x0, 0x0) (async)
-r11 = syz_kvm_add_vcpu$arm64(r9, &(0x7f0000000100)={0x0, &(0x7f00000001c0)=ANY=[@ANYBLOB="050000"], 0x18}, 0x0, 0x0)
+#
+# The line used to look as follows, but syz_kvm_add_vcpu() does not support ANY anymore.
+# r11 = syz_kvm_add_vcpu$arm64(r9, &(0x7f0000000100)={0x0, &(0x7f00000001c0)=ANY=[@ANYBLOB="050000"], 0x18}, 0x0, 0x0)
+# Just replaced it with something relevant.
+#
+r11 = syz_kvm_add_vcpu$arm64(r9, &(0x7f0000000100)={0x0, &(0x7f00000001c0)=[@irq_setup={0x5, 0x18, {0x0, 0x0}}], 0x18}, 0x0, 0x0)
 syz_kvm_vgic_v3_setup(r8, 0x2, 0x100) (async)
 ioctl$KVM_RUN(r11, 0xae80, 0x0) (async)
 ioctl$KVM_RUN(r10, 0xae80, 0x0)
diff --git a/sys/linux/test/arm64-kvm-bug372635024 b/sys/linux/test/arm64-kvm-bug372635024
index 35ea607c9..cc247910e 100644
--- a/sys/linux/test/arm64-kvm-bug372635024
+++ b/sys/linux/test/arm64-kvm-bug372635024
@@ -4,7 +4,12 @@
 r0 = openat$kvm(0x0, &(0x7f0000000040), 0x0, 0x0)
 r1 = ioctl$KVM_CREATE_VM(r0, 0xae01, 0x0)
 r2 = syz_kvm_setup_syzos_vm$arm64(r1, &(0x7f0000c00000/0x400000)=nil)
-r3 = syz_kvm_add_vcpu$arm64(r2, &(0x7f0000000080)={0x0, &(0x7f0000000240)=ANY=[@ANYBLOB="05000000000000001800000000000000010000005002"], 0x18}, 0x0, 0x0)
+#
+# The line used to look as follows, but syz_kvm_add_vcpu() does not support ANY anymore.
+# r3 = syz_kvm_add_vcpu$arm64(r2, &(0x7f0000000080)={0x0, &(0x7f0000000240)=ANY=[@ANYBLOB="05000000000000001800000000000000010000005002"], 0x18}, 0x0, 0x0)
+# Just replaced it with something relevant.
+#
+r3 = syz_kvm_add_vcpu$arm64(r2, &(0x7f0000000080)={0x0, &(0x7f0000000240)=[@irq_setup={0x5, 0x18, {0x0, 0x0}}], 0x18}, 0x0, 0x0)
 ioctl$KVM_RUN(r3, 0xae80, 0x0)
 ioctl$KVM_SET_VCPU_EVENTS(r3, 0x4040aea0, &(0x7f0000000000)=@arm64={0x0, 0x1, 0xf, '\x00', 0xfffffffffffff105, ""})
 ioctl$KVM_RUN(r3, 0xae80, 0x0)
diff --git a/sys/test/test.txt b/sys/test/test.txt
index 71ec2a011..54cf96f9b 100644
--- a/sys/test/test.txt
+++ b/sys/test/test.txt
@@ -799,6 +799,15 @@ hint_ints {
 }
 
 # Mutation tests.
+no_squash_struct {
+	f0	int32
+	f1	int32
+	f2	int32
+	f3	int32
+	f4	array[int8]
+} [packed]
+
+mutate_no_squash(a ptr[in, no_squash_struct]) (no_squash)
 
 mutate0()
 mutate1()
diff --git a/syz-kfuzztest/main.go b/syz-kfuzztest/main.go
new file mode 100644
index 000000000..e46ecc257
--- /dev/null
+++ b/syz-kfuzztest/main.go
@@ -0,0 +1,61 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+package main
+
+import (
+	"context"
+	"flag"
+	"fmt"
+	"os"
+
+	manager "github.com/google/syzkaller/pkg/kfuzztest-manager"
+	"github.com/google/syzkaller/pkg/osutil"
+)
+
+var (
+	flagVmlinux         = flag.String("vmlinux", "vmlinux", "path to vmlinux binary")
+	flagCooldown        = flag.Int("cooldown", 0, "cooldown between KFuzzTest target invocations in seconds")
+	flagThreads         = flag.Int("threads", 2, "number of threads")
+	flagDisplayInterval = flag.Int("display", 5, "number of seconds between console outputs")
+)
+
+func main() {
+	usage := func() {
+		w := flag.CommandLine.Output()
+		fmt.Fprintf(w, "usage: %s [flags] [enabled targets]\n\n", os.Args[0])
+		fmt.Fprintln(w, `Args:
+  One fuzz test name per enabled fuzz test arg. If empty, defaults to
+  all discovered targets.`)
+		fmt.Fprintln(w, `Example:
+  ./syz-kfuzztest -vmlinux ~/kernel/vmlinux fuzz_target_0 fuzz_target_1`)
+		fmt.Fprintln(w, "Flags:")
+		flag.PrintDefaults()
+	}
+	flag.Usage = usage
+	flag.Parse()
+	enabledTargets := flag.Args()
+
+	cfg := manager.Config{
+		VmlinuxPath:     *flagVmlinux,
+		Cooldown:        uint32(*flagCooldown),
+		DisplayInterval: uint32(*flagDisplayInterval),
+		NumThreads:      *flagThreads,
+		EnabledTargets:  enabledTargets,
+	}
+
+	ctx, cancel := context.WithCancel(context.Background())
+	defer cancel()
+
+	shutdownChan := make(chan struct{})
+	osutil.HandleInterrupts(shutdownChan)
+	go func() {
+		<-shutdownChan
+		cancel()
+	}()
+
+	mgr, err := manager.NewKFuzzTestManager(ctx, cfg)
+	if err != nil {
+		panic(err)
+	}
+	mgr.Run(ctx)
+}
diff --git a/syz-manager/manager.go b/syz-manager/manager.go
index 3f94bd23a..67af3bb29 100644
--- a/syz-manager/manager.go
+++ b/syz-manager/manager.go
@@ -15,6 +15,7 @@ import (
 	"net"
 	"os"
 	"os/exec"
+	"path"
 	"path/filepath"
 	"sort"
 	"sync"
@@ -31,6 +32,7 @@ import (
 	"github.com/google/syzkaller/pkg/gce"
 	"github.com/google/syzkaller/pkg/ifaceprobe"
 	"github.com/google/syzkaller/pkg/image"
+	"github.com/google/syzkaller/pkg/kfuzztest"
 	"github.com/google/syzkaller/pkg/log"
 	"github.com/google/syzkaller/pkg/manager"
 	"github.com/google/syzkaller/pkg/mgrconfig"
@@ -241,6 +243,14 @@ func main() {
 		cfg.DashboardClient = ""
 		cfg.HubClient = ""
 	}
+	if cfg.Experimental.EnableKFuzzTest {
+		vmLinuxPath := path.Join(cfg.KernelObj, cfg.SysTarget.KernelObject)
+		log.Log(0, "enabling KFuzzTest targets")
+		_, err := kfuzztest.ActivateKFuzzTargets(cfg.Target, vmLinuxPath)
+		if err != nil {
+			log.Fatalf("failed to enable KFuzzTest targets: %v", err)
+		}
+	}
 	RunManager(mode, cfg)
 }
 
@@ -1113,6 +1123,22 @@ func (mgr *Manager) MachineChecked(features flatrpc.Feature,
 		mgr.exit(mgr.mode.Name)
 	}
 
+	// If KFuzzTest is enabled, we exclusively fuzz KFuzzTest targets - so
+	// delete any existing entries in enabled syscalls, and enable all
+	// discovered KFuzzTest targets explicitly.
+	if mgr.cfg.Experimental.EnableKFuzzTest {
+		for call := range enabledSyscalls {
+			delete(enabledSyscalls, call)
+		}
+		data, err := kfuzztest.ExtractData(path.Join(mgr.cfg.KernelObj, "vmlinux"))
+		if err != nil {
+			return nil, err
+		}
+		for _, call := range data.Calls {
+			enabledSyscalls[call] = true
+		}
+	}
+
 	mgr.mu.Lock()
 	defer mgr.mu.Unlock()
 	if mgr.phase != phaseInit {
@@ -1160,6 +1186,7 @@ func (mgr *Manager) MachineChecked(features flatrpc.Feature,
 				defer mgr.mu.Unlock()
 				return !mgr.saturatedCalls[call]
 			},
+			ModeKFuzzTest: mgr.cfg.Experimental.EnableKFuzzTest,
 		}, rnd, mgr.target)
 		fuzzerObj.AddCandidates(candidates)
 		mgr.fuzzer.Store(fuzzerObj)
diff --git a/tools/check-syzos.sh b/tools/check-syzos.sh
new file mode 100755
index 000000000..2b8a72a60
--- /dev/null
+++ b/tools/check-syzos.sh
@@ -0,0 +1,122 @@
+#!/bin/sh
+# Copyright 2025 syzkaller project authors. All rights reserved.
+# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+#
+# This script scans the syz-executor binary for data relocations accesses
+# within the "guest" ELF section that are problematic for the SYZOS guest
+# code.
+#
+# It uses $TARGETOS and $TARGETARCH to locate the binary and determine the
+# correct architecture.
+#
+
+set -e
+
+SECTION_TO_CHECK="guest"
+
+echoerr() {
+    echo "$@" >&2
+}
+
+if [ "$TARGETOS" != "linux" ]; then
+    echo "[INFO] TARGETOS is '$TARGETOS', not 'linux'. Skipping check."
+    exit 0
+fi
+
+if [ -z "$TARGETARCH" ]; then
+    echoerr "Error: \$TARGETARCH environment variable is not set."
+    exit 1
+fi
+
+BINARY="bin/${TARGETOS}_${TARGETARCH}/syz-executor"
+
+if [ ! -f "$BINARY" ]; then
+    echoerr "Error: Binary not found at '$BINARY'"
+    exit 1
+fi
+
+echoerr "--> Analyzing architecture '$TARGETARCH'..."
+OBJDUMP_CMD=""
+
+if [ "$TARGETARCH" = "amd64" ]; then
+    ARCH="x86_64"
+    PATTERNS_TO_FIND='\\(%rip\\)'
+    if command -v x86_64-linux-gnu-objdump > /dev/null; then
+        OBJDUMP_CMD="x86_64-linux-gnu-objdump"
+    fi
+elif [ "$TARGETARCH" = "arm64" ]; then
+    ARCH="aarch64"
+    PATTERNS_TO_FIND='adrp'
+    if command -v aarch64-linux-gnu-objdump > /dev/null; then
+        OBJDUMP_CMD="aarch64-linux-gnu-objdump"
+    fi
+else
+    echo "[INFO] Unsupported architecture '$TARGETARCH', skipping check."
+    exit 0
+fi
+echoerr "--> Detected architecture: $ARCH"
+
+if [ -z "$OBJDUMP_CMD" ]; then
+    echoerr "--> Arch-specific objdump not found, falling back to generic 'objdump'..."
+    if command -v objdump > /dev/null; then
+        OBJDUMP_CMD="objdump"
+    fi
+fi
+
+if [ -z "$OBJDUMP_CMD" ]; then
+    echoerr "Error: Could not find a usable objdump binary."
+    exit 1
+fi
+echoerr "--> Using objdump: $OBJDUMP_CMD"
+
+echoerr "--> Verifying existence of section '$SECTION_TO_CHECK' in '$BINARY'..."
+if ! "$OBJDUMP_CMD" -h --section="$SECTION_TO_CHECK" "$BINARY" >/dev/null 2>&1; then
+    echo
+    echo "[INFO] Section '$SECTION_TO_CHECK' not found in '$BINARY'. Skipping check."
+    exit 0
+fi
+
+echoerr "--> Disassembling section '$SECTION_TO_CHECK' and scanning for patterns ('$PATTERNS_TO_FIND')..."
+
+DISASSEMBLY_STATUS=0
+DISASSEMBLY_OUTPUT=$("$OBJDUMP_CMD" -d --section="$SECTION_TO_CHECK" "$BINARY" 2>/dev/null) || DISASSEMBLY_STATUS=$?
+
+if [ $DISASSEMBLY_STATUS -ne 0 ]; then
+    echoerr "Error: '$OBJDUMP_CMD' failed to disassemble the '$SECTION_TO_CHECK' section."
+    # Attempt to show the actual error to the user
+    "$OBJDUMP_CMD" -d --section="$SECTION_TO_CHECK" "$BINARY" >/dev/null
+    exit 1
+fi
+
+FOUND_INSTRUCTIONS=$(echo "$DISASSEMBLY_OUTPUT" | awk -v pattern="$PATTERNS_TO_FIND" '
+    # Match a function header, e.g., "0000000000401136 <my_func>:"
+    /^[0-9a-f]+ <.*>:$/ {
+        match($0, /<.*>/)
+        current_func = substr($0, RSTART, RLENGTH)
+    }
+    # If the line matches the instruction pattern, print the context.
+    $0 ~ pattern {
+        if (current_func) {
+            print "In function " current_func ":"
+        }
+        print "\t" $0
+    }
+' || true)
+
+if [ -n "$FOUND_INSTRUCTIONS" ]; then
+    echo
+    echo "------------------------------------------------------------------"
+    echo "[FAIL] Found problematic data access instructions in '$SECTION_TO_CHECK'."
+    echo "The following instructions are likely to cause crashes in SyzOS:"
+    echo "$FOUND_INSTRUCTIONS" | sed 's/^/  /'
+    echo "------------------------------------------------------------------"
+    echo
+    echo "This typically happens when the C compiler emits read-only constants for"
+    echo "zero-initializing structs or for jump tables in switch statements."
+    exit 1
+else
+    # Do not print anything to stdout unless there's an error.
+    echoerr
+    echoerr "[OK] No problematic data access instructions found in '$SECTION_TO_CHECK'."
+    exit 0
+fi
diff --git a/tools/kfuzztest-gen/main.go b/tools/kfuzztest-gen/main.go
new file mode 100644
index 000000000..c469c3916
--- /dev/null
+++ b/tools/kfuzztest-gen/main.go
@@ -0,0 +1,47 @@
+// Copyright 2025 syzkaller project authors. All rights reserved.
+// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
+
+// Small tool for systematically outputting syzlang descriptions of KFuzzTest
+// of a vmlinux binary.
+package main
+
+import (
+	"fmt"
+	"io"
+	"os"
+
+	"github.com/google/syzkaller/pkg/kfuzztest"
+	"github.com/google/syzkaller/pkg/log"
+	"github.com/google/syzkaller/pkg/tool"
+)
+
+func main() {
+	usage := func(w io.Writer) {
+		fmt.Fprintln(w, "usage: ./kfuzztest-gen /path/to/vmlinux")
+	}
+	if len(os.Args) != 2 {
+		usage(os.Stderr)
+		os.Exit(1)
+	}
+
+	extractor, err := kfuzztest.NewExtractor(os.Args[1])
+	if err != nil {
+		tool.Fail(err)
+	}
+	defer extractor.Close()
+
+	log.Log(0, "extracting ELF data")
+	res, err := extractor.ExtractAll()
+	if err != nil {
+		tool.Fail(err)
+	}
+	log.Log(0, res.String())
+
+	builder := kfuzztest.NewBuilder(res.Funcs, res.Structs, res.Constraints, res.Annotations)
+	desc, err := builder.EmitSyzlangDescription()
+	if err != nil {
+		tool.Fail(err)
+	}
+	log.Logf(0, "emitting syzlang description")
+	fmt.Println(desc)
+}
diff --git a/tools/syz-prog2c/prog2c.go b/tools/syz-prog2c/prog2c.go
index 27476ffbf..f5402041d 100644
--- a/tools/syz-prog2c/prog2c.go
+++ b/tools/syz-prog2c/prog2c.go
@@ -11,6 +11,7 @@ import (
 	"runtime"
 
 	"github.com/google/syzkaller/pkg/csource"
+	"github.com/google/syzkaller/pkg/kfuzztest"
 	"github.com/google/syzkaller/prog"
 	_ "github.com/google/syzkaller/sys"
 )
@@ -33,6 +34,7 @@ var (
 	flagLeak       = flag.Bool("leak", false, "do leak checking")
 	flagEnable     = flag.String("enable", "none", "enable only listed additional features")
 	flagDisable    = flag.String("disable", "none", "enable all additional features except listed")
+	flagVmlinux    = flag.String("vmlinux", "", "path to vmlinux binary (required for dynamically discovered calls")
 )
 
 func main() {
@@ -54,6 +56,13 @@ func main() {
 		fmt.Fprintf(os.Stderr, "%v\n", err)
 		os.Exit(1)
 	}
+	if *flagVmlinux != "" {
+		_, err = kfuzztest.ActivateKFuzzTargets(target, *flagVmlinux)
+		if err != nil {
+			fmt.Fprintf(os.Stderr, "%v\n", err)
+			os.Exit(1)
+		}
+	}
 	data, err := os.ReadFile(*flagProg)
 	if err != nil {
 		fmt.Fprintf(os.Stderr, "failed to read prog file: %v\n", err)
